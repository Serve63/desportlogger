<!doctype html>
<html lang="nl">
<head> <meta charset="utf-8" /> <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />

  <meta name="theme-color" content="#15181d" />
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Servé's Logboek" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="application-name" content="Servé's Logboek" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="manifest" href="/manifest.webmanifest?v=20260205" />
 <title>Logboek - Donderdag</title> 
  
  <style>
    @import url("https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600&family=DM+Serif+Display&display=swap");

    :root {
      --ink: #eef0f3;
      --muted: #c2c6cc;
      --line: #6a6f78;
      --stroke: #7a8089;
      --field: #3b3f45;
      --page-top: 113px;
      --page-bottom: 72px;
      --footer-offset: 72px;
    
      --exercise-font: 0.5rem;
      --note-font: 0.4rem;
      --mini-font: 0.75rem;
    }

    * {
      box-sizing: border-box;
    }

    html {
      background-color: #15181d;
    }

    html, body {
      overflow: hidden;
      min-height: 100vh;
      min-height: 100svh;
      min-height: 100dvh;
      height: 100vh;
      height: 100svh;
      height: 100dvh;
      background:
        linear-gradient(180deg, #1a2634, transparent 120px),
        radial-gradient(ellipse 900px 600px at 15% -8%, rgba(74, 163, 255, 0.13), transparent 60%),
        radial-gradient(ellipse 700px 500px at 85% 5%, rgba(74, 163, 255, 0.08), transparent 55%),
        radial-gradient(ellipse 600px 400px at 50% 105%, rgba(74, 163, 255, 0.06), transparent 50%),
        #15181d;
      touch-action: pan-y;
      overscroll-behavior: none;
    }

    body::-webkit-scrollbar {
      width: 0;
      height: 0;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background-image: radial-gradient(circle at 1px 1px, rgba(255, 255, 255, 0.03) 1px, transparent 0);
      background-size: 24px 24px;
      pointer-events: none;
      z-index: 0;
    }

    body::after {
      content: "";
      position: fixed;
      inset: 0;
      background:
        radial-gradient(ellipse 500px 300px at 70% 65%, rgba(74, 163, 255, 0.04), transparent 60%),
        radial-gradient(ellipse 400px 250px at 25% 80%, rgba(255, 255, 255, 0.015), transparent 50%);
      pointer-events: none;
      z-index: 0;
    }

    .pwa-bottom-fade {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      height: 120px;
      background: linear-gradient(180deg, rgba(21, 24, 29, 0) 0%, #15181d 100%);
      pointer-events: none;
      z-index: 1;
      display: none;
    }

    @media (display-mode: standalone) {
      .pwa-bottom-fade {
        display: block;
      }
    }

    body {
      margin: 0;
      font-family: "DM Sans", sans-serif;
      color: var(--ink);
      background:
        linear-gradient(180deg, #1a2634, transparent 120px),
        radial-gradient(ellipse 900px 600px at 15% -8%, rgba(74, 163, 255, 0.13), transparent 60%),
        radial-gradient(ellipse 700px 500px at 85% 5%, rgba(74, 163, 255, 0.08), transparent 55%),
        radial-gradient(ellipse 600px 400px at 50% 105%, rgba(74, 163, 255, 0.06), transparent 50%),
        #15181d;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: var(--page-top) 12px calc(var(--page-bottom) + env(safe-area-inset-bottom));
      -webkit-user-select: none;
      user-select: none;
    }



    input,
    textarea {
      -webkit-user-select: text;
      user-select: text;
    }

    
    .sheet::-webkit-scrollbar {
      width: 0;
      height: 0;
    }

    .sheet {

      scrollbar-width: none;
      width: min(980px, 100%);
      padding: 8px 2px 18px;
      position: relative;
      max-height: calc(100vh - var(--page-top) - var(--page-bottom) - env(safe-area-inset-bottom));
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      touch-action: pan-y;
    }

    header {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      text-align: center;
      margin-bottom: 18px;
      position: relative;
      z-index: 1;
    }

    h1 {
      font-family: "DM Serif Display", serif;
      font-size: clamp(2.2rem, 3.8vw, 3.4rem);
      margin: 0;
      letter-spacing: 0.02em;
    }

    .training-count {
      margin-top: 72px;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--muted);
    }

    .year-trigger {
      background: none;
      border: none;
      padding: 0;
      margin: 0;
      font: inherit;
      color: var(--ink);
      font-weight: 700;
      letter-spacing: 0.18em;
      cursor: pointer;
    }

    .day-line {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 6px;
      margin-bottom: 10px;
    }

    .day-trigger {
      background: none;
      border: none;
      padding: 0;
      margin: 0;
      font: inherit;
      color: var(--ink);
      font-weight: 400;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      font-size: 0.7rem;
      cursor: pointer;
    }

    .grid {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .grid.rest-day {
      min-height: 55vh;
      justify-content: center;
      align-items: center;
      text-align: center;
    }

    .grid.rest-day .row {
      grid-template-columns: 1fr;
      justify-items: center;
      text-align: center;
    }

    .grid.rest-day .exercise-cell {
      grid-template-columns: 1fr;
      justify-items: center;
      text-align: center;
    }

    .grid.rest-day .exercise-name,
    .grid.rest-day .exercise-note {
      text-align: center;
    }

    .header-row {
      display: grid;
      grid-template-columns: minmax(0, 2fr) 42px 42px 42px;
      column-gap: 8px;
      align-items: end;
    }

    .grid .header {
      font-weight: 600;
      text-transform: uppercase;
      font-size: 0.5rem;
      letter-spacing: 0.12em;
      color: var(--muted);
      padding-bottom: 6px;
      text-align: center;
    }

    .grid .header.exercise-header {
      text-align: left;
    }

    .row {
      display: grid;
      grid-template-columns: minmax(0, 2fr) 42px 42px 42px;
      column-gap: 8px;
      row-gap: 10px;
      align-items: start;
    }

    .exercise-cell {
      display: grid;
      grid-template-columns: 20px 1fr;
      column-gap: 4px;
      row-gap: 4px;
      align-items: center;
      min-width: 0;
    }

    .drag-handle {
      grid-column: 1;
      grid-row: 1;
      align-self: start;
      width: 44px;
      height: 44px;
      margin: -12px;
      border-radius: 12px;
      border: 1px solid transparent;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.16);
      color: #eef0f3;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: grab;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      touch-action: none;
      padding: 0;
      transition: transform 0.12s ease, border-color 0.18s ease, background 0.18s ease, box-shadow 0.18s ease;
    }

    .drag-handle::before {
      content: "";
      display: block;
      width: 12px;
      height: 2px;
      border-radius: 2px;
      background: rgba(196, 224, 255, 0.9);
      box-shadow: 0 4px 0 rgba(196, 224, 255, 0.9), 0 8px 0 rgba(196, 224, 255, 0.9);
      transform: translateY(-2px);
      filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.45));
    }

    .drag-handle:hover,
    .drag-handle:focus-visible {
      border-color: rgba(74, 163, 255, 0.55);
      background: linear-gradient(180deg, rgba(74, 163, 255, 0.18), rgba(255, 255, 255, 0.04));
      box-shadow: 0 8px 18px rgba(18, 39, 76, 0.35);
      outline: none;
    }

    .drag-handle:active {
      cursor: grabbing;
      transform: scale(0.94);
    }

    .row.is-dragging-floating {
      position: fixed;
      z-index: 1300;
      pointer-events: none;
      opacity: 0.98;
      background: rgba(47, 51, 56, 0.96);
      border-radius: 14px;
      box-shadow: 0 14px 36px rgba(0, 0, 0, 0.42), 0 0 0 1px rgba(74, 163, 255, 0.3);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }

    .row.reorder-placeholder {
      display: block !important;
      min-height: 48px;
      border-radius: 12px;
      border: 1px dashed rgba(74, 163, 255, 0.48);
      background: linear-gradient(180deg, rgba(74, 163, 255, 0.12), rgba(74, 163, 255, 0.04));
      box-shadow: inset 0 0 0 1px rgba(74, 163, 255, 0.15);
    }

    .row.reorder-drop-target {
      box-shadow: 0 0 0 1px rgba(74, 163, 255, 0.26);
      border-radius: 12px;
      transition: box-shadow 0.12s ease;
    }

    body.is-dragging-active {
      cursor: grabbing;
      -webkit-user-select: none;
      user-select: none;
    }


    .exercise-cell .exercise-name,
    .exercise-cell .exercise-note {
      font-style: italic;
      grid-column: 2;
      grid-row: 2;
      border: none;
      background: transparent;
      padding: 2px 0;
      color: var(--ink);
      font: inherit;
      width: 100%;
    }


    .exercise-cell .exercise-name:focus,
    .exercise-cell .exercise-note:focus,
    .exercise-cell .exercise-name:focus-visible,
    .exercise-cell .exercise-note:focus-visible {
      outline: none;
      box-shadow: none;
    }





    .exercise-cell .exercise-name {
      grid-column: 2;
      grid-row: 1;
      font-size: 1rem;
      font-weight: 500;
    }

    .exercise-cell .exercise-note {
      grid-column: 2;
      grid-row: 2;
      color: #c6c8cc;
      font-size: var(--note-font);
      resize: none;
      overflow: hidden;
      line-height: 1.35;
      margin: 0;
      -webkit-appearance: none;
      appearance: none;
      min-height: 1.4em;
    }

    .exercise-cell .exercise-note::-webkit-resizer {
      display: none;
    }

    .mini-wrap {
      display: flex;
      justify-content: center;
    }

    .mini-field {
      border: 1px solid rgba(74, 163, 255, 0.25);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.02));
      border-radius: 8px;
      width: 42px;
      height: 42px;
      padding: 0;
      text-align: center;
      font-size: var(--mini-font);
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: var(--ink);
      box-shadow: none;
      transition: transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease, background 0.12s ease;
    }

    .mini-field:focus {
      outline: none;
      border-color: rgba(74, 163, 255, 0.7);
      background: linear-gradient(180deg, rgba(74, 163, 255, 0.18), rgba(255, 255, 255, 0.04));
    }


    .year-modal,
    .day-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(10, 10, 12, 0.45);
      z-index: 1000;
      padding: 24px;
    }

    .year-modal.is-open,
    .day-modal.is-open {
      display: flex;
    }

    .year-modal__content,
    .day-modal__content {
      width: min(420px, 100%);
      background: #3b3f45;
      color: #f1f2f4;
      border-radius: 14px;
      padding: 20px 20px 18px;
      border: 1px solid #b9bcc3;
      box-shadow: 0 14px 28px rgba(0, 0, 0, 0.35);
      position: relative;
    }

    .year-modal__content h2,
    .day-modal__content h2 {
      margin: 0 0 12px;
      font-size: 1.05rem;
    }

    .year-modal__list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 8px;
      font-size: 0.95rem;
    }

    .year-total {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #b9bcc3;
    }

    .day-modal__grid {
      display: grid;
      gap: 8px;
    }

    .day-modal__grid a {
      text-decoration: none;
      color: #f1f2f4;
      background: #2f3338;
      border: 1px solid #b9bcc3;
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 600;
      text-align: center;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      transition: transform 0.1s ease, background-color 0.15s ease, opacity 0.1s ease;
      cursor: pointer;
    }

    .day-modal__grid a:hover {
      background: #3b3f45;
    }

    .day-modal__grid a:active {
      transform: scale(0.96);
      opacity: 0.85;
    }

    .day-modal__grid a.is-today {
      color: #4aa3ff;
    }

    .exercise-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(10, 10, 12, 0.45);
      z-index: 1000;
      padding: 24px;
    }

    .exercise-modal.is-open {
      display: flex;
    }

    .exercise-modal__content {
      width: min(320px, 90%);
      background: #3b3f45;
      color: #f1f2f4;
      border-radius: 14px;
      padding: 20px 20px 18px;
      border: 1px solid #b9bcc3;
      box-shadow: 0 14px 28px rgba(0, 0, 0, 0.35);
      position: relative;
    }

    .exercise-modal__content h2 {
      margin: 0 0 16px;
      font-size: 1.05rem;
    }

    .exercise-modal__actions {
      display: grid;
      gap: 10px;
    }

    .exercise-modal__actions button {
      text-decoration: none;
      color: #f1f2f4;
      background: #2f3338;
      border: 1px solid #b9bcc3;
      border-radius: 10px;
      padding: 12px 16px;
      font-weight: 600;
      text-align: center;
      font-size: 0.95rem;
      cursor: pointer;
      font-family: inherit;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    .exercise-modal__actions button:hover {
      background: #3b3f45;
    }

    .exercise-modal__actions button.delete {
      color: #ff6b6b;
      border-color: #ff6b6b;
    }

    .exercise-modal__actions button.delete:hover {
      background: rgba(255, 107, 107, 0.1);
    }

    .year-modal__close,
    .day-modal__close,
    .exercise-modal__close {
      position: absolute;
      top: 10px;
      right: 12px;
      border: none;
      background: transparent;
      font-size: 1.5rem;
      cursor: pointer;
      color: #f1f2f4;
    }


    .session-check-button {
      position: fixed;
      bottom: calc(var(--footer-offset) + env(safe-area-inset-bottom));
      left: 50%;
      transform: translateX(-50%);
      width: 42px;
      height: 42px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.15), transparent 50%), rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(12px) saturate(120%);
      -webkit-backdrop-filter: blur(12px) saturate(120%);
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 1000;
      transition: transform 0.15s cubic-bezier(0.2, 0, 0, 1),
                  background-color 0.25s ease,
                  border-color 0.25s ease;
      -webkit-tap-highlight-color: transparent;
    }

    .session-check-button.is-today {
      display: flex;
    }

    .session-check-button:active {
      transform: translateX(-50%) scale(0.92);
    }

    .session-check-button.is-complete {
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.4), transparent 50%), #4aa3ff;
      border-color: rgba(74, 163, 255, 0.8);
      animation: checkPop 0.35s cubic-bezier(0.17, 0.67, 0.21, 1.2);
    }

    @keyframes checkPop {
      0% { transform: translateX(-50%) scale(1); }
      40% { transform: translateX(-50%) scale(1.2); }
      100% { transform: translateX(-50%) scale(1); }
    }

    .session-check-button.is-complete::after {
      content: "\2713";
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: 700;
      color: #eaffef;
    }



    html.not-today .session-check-button,
    body.not-today .session-check-button {
      display: none;
    }

    @media (max-width: 720px) {
      body {
        padding: var(--page-top) 16px calc(var(--page-bottom) + env(safe-area-inset-bottom));
      }

      :root {
        --page-top: 73px;
        --page-bottom: 96px;
        --footer-offset: 68px;
      
        --exercise-font: 10px;
        --note-font: 9px;
        --mini-font: 16px;
      }

      header {
        gap: 6px;
        margin-bottom: 12px;
      }

      h1 {
        font-size: clamp(1.8rem, 6vw, 2.2rem);
      }

      .training-count {
        margin-top: 12px;
        font-size: 0.7rem;
        letter-spacing: 0.14em;
      }

      .header-row {
        grid-template-columns: minmax(0, 1.4fr) 40px 40px 40px;
        column-gap: 10px;
      }

      .row {
        grid-template-columns: minmax(0, 1.4fr) 40px 40px 40px;
        column-gap: 10px;
      }

      .mini-field {
        width: 40px;
        height: 40px;
      }
    }

    @media (max-width: 520px) {
      .header-row {
        grid-template-columns: minmax(0, 1fr) 36px 36px 36px;
        column-gap: 8px;
      }

      .row {
        grid-template-columns: minmax(0, 1fr) 36px 36px 36px;
        column-gap: 8px;
      }

      .mini-field {
        width: 36px;
        height: 36px;
      }
    }
  

    .confetti-layer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      margin: 0;
      padding: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 9999;
    }

    .confetti {
      position: absolute;
      top: -30px;
      opacity: 0;
      display: block;
      font-size: 24px;
      line-height: 1;
      animation: confettiFall var(--fall-duration, 4s) var(--fall-delay, 0s) ease-out forwards;
    }

    @keyframes confettiFall {
      0% {
        opacity: 1;
        transform: translateY(0) translateX(0) rotateX(0deg) rotateY(0deg) rotateZ(0deg);
      }
      10% {
        opacity: 1;
      }
      90% {
        opacity: 1;
      }
      100% {
        opacity: 0;
        transform:
          translateY(calc(100vh + 50px))
          translateX(var(--sway, 0px))
          rotateX(var(--spin-x, 720deg))
          rotateY(var(--spin-y, 540deg))
          rotateZ(var(--spin-z, 360deg));
      }
    }


    .loading-overlay {
      position: fixed;
      inset: 0;
      background:
        radial-gradient(ellipse 900px 600px at 15% -8%, rgba(74, 163, 255, 0.13), transparent 60%),
        radial-gradient(ellipse 700px 500px at 85% 5%, rgba(74, 163, 255, 0.08), transparent 55%),
        radial-gradient(ellipse 600px 400px at 50% 105%, rgba(74, 163, 255, 0.06), transparent 50%),
        #15181d;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      z-index: 9999;
      opacity: 1;
      transition: opacity 0.35s ease;
      pointer-events: all;
    }

    .loading-overlay.is-hidden {
      opacity: 0;
      pointer-events: none;
    }

    .loading-spinner {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 2px solid rgba(74, 163, 255, 0.25);
      border-top-color: #4aa3ff;
      animation: loading-spin 0.9s linear infinite;
    }

    .loading-text {
      font-size: 0.72rem;
      letter-spacing: 0.22em;
      text-transform: uppercase;
      color: #c2c6cc;
    }

    @keyframes loading-spin {
      to {
        transform: rotate(360deg);
      }
    }

</style>

</head>
<body>
  <div class="pwa-bottom-fade" aria-hidden="true"></div>
  <script id="todayGuard">
    (function() {
      try {
        const hashDay = (window.location.hash || "").replace("#", "");
        const path = window.location.pathname;
        const hashMap = {
          maandag: 1,
          dinsdag: 2,
          woensdag: 3,
          donderdag: 4,
          vrijdag: 5,
          zaterdag: 6,
          zondag: 0
        };
        const getPageDayNumber = () => {
          if (hashDay) {
            if (hashDay === "vandaag") return new Date().getDay();
            return hashMap[hashDay] ?? 1;
          }
          if (path.includes("vandaag")) return new Date().getDay();
          if (path.includes("dinsdag")) return 2;
          if (path.includes("woensdag")) return 3;
          if (path.includes("donderdag")) return 4;
          if (path.includes("vrijdag")) return 5;
          if (path.includes("zaterdag")) return 6;
          if (path.includes("zondag")) return 0;
          return 1;
        };
        const isToday = new Date().getDay() === getPageDayNumber();
        document.documentElement.classList.toggle("not-today", !isToday);
      } catch (e) {
        // silent
      }
    })();
  </script>
  <div class="loading-overlay" id="loadingOverlay" aria-live="polite" aria-atomic="true">
    <div class="loading-spinner" aria-hidden="true"></div>
    <div class="loading-text">Laden...</div>
  </div>

 <main class="sheet"> <header> <div> <div class="training-count"><button class="year-trigger" type="button">2026:</button> Laden...</div> <h1>Servé's Logboek</h1> <div class="day-line"><button class="day-trigger" type="button">Vandaag</button></div></div>
</header> <section class="grid" aria-label="Oefeningen">
      <div class="header-row">
        <div class="header exercise-header"></div> <div class="header">SETS</div> <div class="header">REPS</div> <div class="header">KG</div></div> <div class="row"> <div class="exercise-cell"> <input spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off" class="exercise-name" type="text" name="oefening-1" value="Abdominal Machine" /> <textarea spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off" class="exercise-note" name="note-1" rows="2"></textarea></div> <div class="mini-wrap" data-label="Sets"><input type="text" class="mini-field" name="sets-1" data-max="9" inputmode="numeric" pattern="[0-9]*" maxlength="1" value="3" /></div> <div class="mini-wrap" data-label="Reps"><input type="text" class="mini-field" name="reps-1" data-max="30" inputmode="numeric" pattern="[0-9]*" maxlength="2" /></div> <div class="mini-wrap" data-label="Gewicht"><input type="text" class="mini-field" name="gewicht-1" data-max="999" inputmode="numeric" pattern="[0-9]*" maxlength="3" /></div></div> <div class="row"> <div class="exercise-cell"> <input spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off" class="exercise-name" type="text" name="oefening-2" value="Standing Buik" /> <textarea spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off" class="exercise-note" name="note-2" rows="2"></textarea></div> <div class="mini-wrap" data-label="Sets"><input type="text" class="mini-field" name="sets-2" data-max="9" inputmode="numeric" pattern="[0-9]*" maxlength="1" value="3" /></div> <div class="mini-wrap" data-label="Reps"><input type="text" class="mini-field" name="reps-2" data-max="30" inputmode="numeric" pattern="[0-9]*" maxlength="2" /></div> <div class="mini-wrap" data-label="Gewicht"><input type="text" class="mini-field" name="gewicht-2" data-max="999" inputmode="numeric" pattern="[0-9]*" maxlength="3" /></div></div> <div class="row"> <div class="exercise-cell"> <input spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off" class="exercise-name" type="text" name="oefening-3" value="Chest Press" /> <textarea spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off" class="exercise-note" name="note-3" rows="2"></textarea></div> <div class="mini-wrap" data-label="Sets"><input type="text" class="mini-field" name="sets-3" data-max="9" inputmode="numeric" pattern="[0-9]*" maxlength="1" value="3" /></div> <div class="mini-wrap" data-label="Reps"><input type="text" class="mini-field" name="reps-3" data-max="30" inputmode="numeric" pattern="[0-9]*" maxlength="2" /></div> <div class="mini-wrap" data-label="Gewicht"><input type="text" class="mini-field" name="gewicht-3" data-max="999" inputmode="numeric" pattern="[0-9]*" maxlength="3" /></div></div> <div class="row"> <div class="exercise-cell"> <input spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off" class="exercise-name" type="text" name="oefening-4" value="Incline Chest" /> <textarea spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off" class="exercise-note" name="note-4" rows="2"></textarea></div> <div class="mini-wrap" data-label="Sets"><input type="text" class="mini-field" name="sets-4" data-max="9" inputmode="numeric" pattern="[0-9]*" maxlength="1" value="3" /></div> <div class="mini-wrap" data-label="Reps"><input type="text" class="mini-field" name="reps-4" data-max="30" inputmode="numeric" pattern="[0-9]*" maxlength="2" /></div> <div class="mini-wrap" data-label="Gewicht"><input type="text" class="mini-field" name="gewicht-4" data-max="999" inputmode="numeric" pattern="[0-9]*" maxlength="3" /></div></div> <div class="row"> <div class="exercise-cell"> <input spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off" class="exercise-name" type="text" name="oefening-5" value="Overhead Triceps" /> <textarea spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off" class="exercise-note" name="note-5" rows="2"></textarea></div> <div class="mini-wrap" data-label="Sets"><input type="text" class="mini-field" name="sets-5" data-max="9" inputmode="numeric" pattern="[0-9]*" maxlength="1" value="3" /></div> <div class="mini-wrap" data-label="Reps"><input type="text" class="mini-field" name="reps-5" data-max="30" inputmode="numeric" pattern="[0-9]*" maxlength="2" /></div> <div class="mini-wrap" data-label="Gewicht"><input type="text" class="mini-field" name="gewicht-5" data-max="999" inputmode="numeric" pattern="[0-9]*" maxlength="3" /></div></div> <div class="row"> <div class="exercise-cell"> <input spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off" class="exercise-name" type="text" name="oefening-6" value="Tricep Dip" /> <textarea spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off" class="exercise-note" name="note-6" rows="2"></textarea></div> <div class="mini-wrap" data-label="Sets"><input type="text" class="mini-field" name="sets-6" data-max="9" inputmode="numeric" pattern="[0-9]*" maxlength="1" value="3" /></div> <div class="mini-wrap" data-label="Reps"><input type="text" class="mini-field" name="reps-6" data-max="30" inputmode="numeric" pattern="[0-9]*" maxlength="2" /></div> <div class="mini-wrap" data-label="Gewicht"><input type="text" class="mini-field" name="gewicht-6" data-max="999" inputmode="numeric" pattern="[0-9]*" maxlength="3" /></div></div></section></main> <div class="year-modal" id="yearModal" aria-hidden="true"> <div class="year-modal__content" role="dialog" aria-modal="true" aria-labelledby="yearModalTitle"> <button class="year-modal__close" type="button" aria-label="Sluiten">&times;</button> <h2 id="yearModalTitle">Voorgaande jaren</h2> <ul class="year-modal__list"> <li><strong>2022:</strong> 18</li> <li><strong>2023:</strong> 14</li> <li><strong>2024:</strong> 22</li> <li><strong>2025:</strong> 301</li> <li id="yearCount2026"><strong>2026 (tot heden):</strong> 27</li> <li class="year-total"><strong>Totaal:</strong> 382 sessies</li></ul></div></div>

  <div class="day-modal" id="dayModal" aria-hidden="true">
    <div class="day-modal__content" role="dialog" aria-modal="true" aria-labelledby="dayModalTitle">
      <button class="day-modal__close" type="button" aria-label="Sluiten">&times;</button>
      <h2 id="dayModalTitle">Kies een dag</h2>
      <div class="day-modal__grid">
        <a href="#maandag" data-day="maandag">Maandag</a>
        <a href="#dinsdag" data-day="dinsdag">Dinsdag</a>
        <a href="#woensdag" data-day="woensdag">Woensdag</a>
        <a href="#donderdag" data-day="donderdag">Donderdag</a>
        <a href="#vrijdag" data-day="vrijdag">Vrijdag</a>
        <a href="#zaterdag" data-day="zaterdag">Zaterdag</a>
        <a href="#zondag" data-day="zondag">Zondag</a>
      </div>
    </div>
  </div>

  <div class="exercise-modal" id="exerciseModal" aria-hidden="true">
    <div class="exercise-modal__content" role="dialog" aria-modal="true">
      <div class="exercise-modal__actions">
        <button type="button" class="add-exercise">Nieuwe oefening toevoegen</button>
        <button type="button" class="delete-exercise delete">Oefening verwijderen</button>
      </div>
    </div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  
  <script>
    (() => {

      const getBasePath = () => {
        const path = window.location.pathname;
        const daySegments = ["vandaag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag", "zondag"];
        for (const day of daySegments) {
          const token = `/${day}/`;
          const idx = path.indexOf(token);
          if (idx != -1) {
            return path.slice(0, idx + 1);
          }
        }
        const htmlSegments = ["index", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag", "zondag"];
        for (const name of htmlSegments) {
          const token = `/${name}.html`;
          const idx = path.indexOf(token);
          if (idx != -1) {
            return path.slice(0, idx + 1);
          }
        }
        if (!path.endsWith("/") && !path.includes(".")) {
          return `${path}/`;
        }
        return path;
      };
      const basePath = getBasePath();
      const withBase = (p) => `${basePath}${p.replace(/^\//, "")}`;

      window.__appBasePath = basePath;

      const updateAppLinks = () => {
        const manifestLink = document.querySelector('link[rel="manifest"]');
        if (manifestLink) {
          manifestLink.setAttribute("href", withBase("manifest.webmanifest?v=20260205"));
        }
        const appleIcon = document.querySelector('link[rel="apple-touch-icon"]');
        if (appleIcon) {
          appleIcon.setAttribute("href", withBase("apple-touch-icon.png"));
        }
      };
      updateAppLinks();


            // Redirect naar de juiste dag pagina als het niet vandaag is
      const today = new Date().getDay(); // 0 = zondag, 1 = maandag, etc.
      const dayPages = {
        0: withBase("zondag/"),
        1: withBase("maandag/"),
        2: withBase("dinsdag/"),
        3: withBase("woensdag/"),
        4: withBase("donderdag/"),
        5: withBase("vrijdag/"),
        6: withBase("zaterdag/")
      };
      const todayPage = withBase("vandaag/");

      const currentUrl = new URL(window.location.href);
      const storage = (() => { try { return window.sessionStorage; } catch { return null; } })();
      const manualParam = currentUrl.searchParams.get("manual") === "1";
      const manualSession = storage ? storage.getItem("manualView") === "1" : false;
      const manualView = manualParam || manualSession;

      if (manualParam && storage) {
        storage.setItem("manualView", "1");
      }

      const legacyMap = {
        [`${basePath}index.html`]: withBase("maandag/"),
        [`${basePath}dinsdag.html`]: withBase("dinsdag/"),
        [`${basePath}woensdag.html`]: withBase("woensdag/"),
        [`${basePath}donderdag.html`]: withBase("donderdag/"),
        [`${basePath}vrijdag.html`]: withBase("vrijdag/"),
        [`${basePath}zaterdag.html`]: withBase("zaterdag/"),
        [`${basePath}zondag.html`]: withBase("zondag/")
      };


      const path = window.location.pathname;

      if (legacyMap[path]) {
        window.location.replace(`${legacyMap[path]}${currentUrl.search}${currentUrl.hash}`);
        return;
      }

      if (path !== "/index.html" && path.endsWith("/index.html")) {
        const cleanPath = path.slice(0, -10);
        window.location.replace(`${cleanPath}${currentUrl.search}${currentUrl.hash}`);
        return;
      }

      if (path === basePath || path === basePath.slice(0, -1)) {
        window.location.replace(todayPage);
        return;
      }

      if (!path.endsWith("/") && !path.includes(".")) {
        window.location.replace(`${path}/${currentUrl.search}${currentUrl.hash}`);
        return;
      }

      const todayDayPage = dayPages[today];
      const currentPage = path.endsWith("/") ? path : `${path}/`;

      if (currentPage === todayPage && manualSession && storage) {
        storage.removeItem("manualView");
      }

      if (currentPage === todayDayPage && currentPage !== todayPage) {
        window.location.replace(todayPage);
        return;
      }

      // Als de huidige pagina niet de pagina van vandaag is, redirect (behalve bij handmatige keuze)
      if (currentPage !== todayPage && !manualView) {
        window.location.replace(todayPage);
        return; // Stop verdere uitvoering
      }

      
      const loadingOverlay = document.getElementById("loadingOverlay");
      let hasDataLoaded = false;
      const hideLoadingOverlay = (force = false) => {
        if (!loadingOverlay || loadingOverlay.classList.contains("is-hidden")) return;
        if (!force && !hasDataLoaded) return;
        loadingOverlay.classList.add("is-hidden");
        setTimeout(() => {
          if (loadingOverlay && loadingOverlay.parentNode) {
            loadingOverlay.parentNode.removeChild(loadingOverlay);
          }
        }, 400);
      };

      const scheduleForceHide = () => {
        setTimeout(() => hideLoadingOverlay(true), 3500);
      };

      window.addEventListener("load", () => {
        scheduleForceHide();
      });

      const dayTrigger = document.querySelector(".day-trigger");
      const dayModal = document.getElementById("dayModal");
      const dayClose = document.querySelector(".day-modal__close");

      if (dayTrigger && dayModal && dayClose) {
        const openDayModal = () => {
          dayModal.classList.add("is-open");
          dayModal.setAttribute("aria-hidden", "false");
        };
        const closeDayModal = () => {
          dayModal.classList.remove("is-open");
          dayModal.setAttribute("aria-hidden", "true");
        };

        dayTrigger.addEventListener("click", () => {
          if (dayModal.classList.contains("is-open")) {
            closeDayModal();
          } else {
            openDayModal();
          }
        });
        dayClose.addEventListener("click", closeDayModal);
        dayModal.addEventListener("click", (event) => {
          if (event.target === dayModal) closeDayModal();
        });
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") closeDayModal();
        });
      }

      const setupYearTrigger = () => {
      const yearTrigger = document.querySelector(".year-trigger");
      const yearModal = document.getElementById("yearModal");
      const yearClose = document.querySelector(".year-modal__close");

      if (yearTrigger && yearModal && yearClose) {
        const openModal = () => {
          yearModal.classList.add("is-open");
          yearModal.setAttribute("aria-hidden", "false");
        };
        const closeModal = () => {
          yearModal.classList.remove("is-open");
          yearModal.setAttribute("aria-hidden", "true");
        };

          // Verwijder oude event listeners door te clonen
          const newYearTrigger = yearTrigger.cloneNode(true);
          yearTrigger.parentNode.replaceChild(newYearTrigger, yearTrigger);

          newYearTrigger.addEventListener("click", () => {
          if (yearModal.classList.contains("is-open")) {
            closeModal();
          } else {
            openModal();
          }
        });
          
          // Setup close button en modal events (alleen eenmalig)
          if (!yearClose.dataset.listenerAttached) {
        yearClose.addEventListener("click", closeModal);
            yearClose.dataset.listenerAttached = "true";
        yearModal.addEventListener("click", (event) => {
          if (event.target === yearModal) closeModal();
        });
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape") closeModal();
        });
      }
        }
      };

      // Initialiseer year trigger bij het laden
      setupYearTrigger();

      const isStandalone = window.matchMedia("(display-mode: standalone)").matches || window.navigator.standalone === true;
      const daySlugToNumber = {
        maandag: 1,
        dinsdag: 2,
        woensdag: 3,
        donderdag: 4,
        vrijdag: 5,
        zaterdag: 6,
        zondag: 0
      };
      const daySlugToName = {
        maandag: "Maandag",
        dinsdag: "Dinsdag",
        woensdag: "Woensdag",
        donderdag: "Donderdag",
        vrijdag: "Vrijdag",
        zaterdag: "Zaterdag",
        zondag: "Zondag"
      };
      const getHashDay = () => {
        const slug = (window.location.hash || "").replace("#", "");
        return slug in daySlugToNumber || slug === "vandaag" ? slug : "";
      };

      // Update day-trigger button tekst: "Vandaag" als het vandaag is, anders de dag naam
      const updateDayTriggerText = () => {
        const dayTrigger = document.querySelector(".day-trigger");
        if (!dayTrigger) return;

        // Bepaal welke dag deze pagina representeert
        const getPageDay = () => {
          const hashDay = getHashDay();
          if (hashDay) {
            if (hashDay === "vandaag") return new Date().getDay();
            return daySlugToNumber[hashDay] ?? 1;
          }
          const path = window.location.pathname;
          if (path.includes("vandaag")) return new Date().getDay();
          if (path.includes("dinsdag")) return 2; // Dinsdag = 2
          if (path.includes("woensdag")) return 3; // Woensdag = 3
          if (path.includes("donderdag")) return 4; // Donderdag = 4
          if (path.includes("vrijdag")) return 5; // Vrijdag = 5
          if (path.includes("zaterdag")) return 6; // Zaterdag = 6
          if (path.includes("zondag")) return 0; // Zondag = 0
          if (path.includes("maandag")) return 1; // Maandag = 1
          return 1; // Maandag = 1 (default voor maandag)
        };

        // Bepaal de dag namen
        const dayNames = ["Zondag", "Maandag", "Dinsdag", "Woensdag", "Donderdag", "Vrijdag", "Zaterdag"];
        
        const today = new Date().getDay(); // 0 = zondag, 1 = maandag, etc.
        const pageDay = getPageDay();
        const pageDayName = dayNames[pageDay];

        // Als het vandaag dezelfde dag is als de pagina, toon "Vandaag", anders de dag naam
        const isToday = today === pageDay;
        dayTrigger.textContent = isToday ? "Vandaag" : pageDayName;
        document.title = `Logboek - ${isToday ? "Vandaag" : pageDayName}`;
      };

      // Update de button tekst bij het laden
      updateDayTriggerText();

      // Update dag-menu links: toon "Vandaag" voor de huidige dag

      
      const updateDayModalLinks = () => {
        const dayModalLinks = document.querySelectorAll(".day-modal__grid a");
        if (!dayModalLinks.length) return;

        const today = new Date().getDay(); // 0 = zondag, 1 = maandag, etc.
        const dayMapping = {
          maandag: 1,
          dinsdag: 2,
          woensdag: 3,
          donderdag: 4,
          vrijdag: 5,
          zaterdag: 6,
          zondag: 0
        };

        dayModalLinks.forEach((link) => {
          const rawHref = link.getAttribute("href") || "";
          const match = rawHref.match(/(maandag|dinsdag|woensdag|donderdag|vrijdag|zaterdag|zondag|vandaag)/);
          const dayKey = link.dataset.day || (match ? match[1] : "");
          const dayNumber = dayMapping[dayKey];
          const isTodayLink = dayNumber !== undefined && dayNumber === today;

          const targetSlug = isTodayLink ? "vandaag" : dayKey;
          if (targetSlug) {
            link.setAttribute("href", `#${targetSlug}`);
          }

          if (isTodayLink) {
            // Bewaar de originele tekst in een data attribuut
            if (!link.dataset.originalText) {
              link.dataset.originalText = link.textContent;
            }
            link.textContent = "Vandaag";
            link.classList.add("is-today");
          } else {
            // Herstel de originele tekst als het niet meer vandaag is
            if (link.dataset.originalText) {
              link.textContent = link.dataset.originalText;
              delete link.dataset.originalText;
            }
            link.classList.remove("is-today");
          }
        });
      };

      // Update de menu links bij het laden
      updateDayModalLinks();

      const updateTodayState = () => {
        const todayNumber = new Date().getDay();
        const pageDayNumber = getPageDayNumber();
        const isTodayNow = todayNumber === pageDayNumber;
        document.body.classList.toggle("not-today", !isTodayNow);
        document.documentElement.classList.toggle("not-today", !isTodayNow);
      };

      const navigateTo = (slug) => {
        if (!slug) return;
        const target = slug.replace("#", "");
        if (!target) return;
        if (getHashDay() === target) return;
        window.location.hash = target;
      };

      const handleRouteChange = () => {
        day = getDayName();
        updateDayTriggerText();
        updateDayModalLinks();
        updateTodayState();
        loadDayData();
      };

      window.addEventListener("hashchange", () => {
        handleRouteChange();
      });

      document.addEventListener("click", (event) => {
        const link = event.target.closest(".day-modal__grid a");
        if (!link) return;
        if (storage) storage.setItem("manualView", "1");
        event.preventDefault();
        if (dayModal) {
          dayModal.classList.remove("is-open");
          dayModal.setAttribute("aria-hidden", "true");
        }
        const rawHref = link.getAttribute("href") || "";
        const targetSlug = rawHref.replace("#", "");
        navigateTo(targetSlug);
      });


      const clampInput = (input) => {
        const max = Number(input.dataset.max || 999);
        input.addEventListener("input", () => {
          let value = input.value.replace(/\D+/g, "");
          if (value === "") {
            input.value = "";
            return;
          }
          const num = Number(value);
          input.value = String(Math.min(num, max));
        });
      };

      document.querySelectorAll("input[data-max]").forEach(clampInput);

      // Cursor altijd achter het laatste cijfer plaatsen bij focus
      const cursorToEnd = (input) => {
        input.addEventListener("focus", () => {
          setTimeout(() => {
            const len = input.value.length;
            input.setSelectionRange(len, len);
          }, 0);
        });
      };
      document.querySelectorAll(".mini-field").forEach(cursorToEnd);

      // Best effort: blokkeer iOS undo/redo acties (incl. shake-to-undo)
      const blockSystemUndoActions = () => {
        document.addEventListener("beforeinput", (event) => {
          if (event.inputType === "historyUndo" || event.inputType === "historyRedo") {
            event.preventDefault();
          }
        }, true);

        document.addEventListener("keydown", (event) => {
          const key = (event.key || "").toLowerCase();
          if ((event.metaKey || event.ctrlKey) && (key === "z" || key === "y")) {
            event.preventDefault();
          }
        }, true);

        let lastShakeBlurAt = 0;
        const blurActiveField = () => {
          const active = document.activeElement;
          if (active && (active.tagName === "INPUT" || active.tagName === "TEXTAREA")) {
            active.blur();
          }
        };

        const handleMotion = (event) => {
          const acc = event.accelerationIncludingGravity;
          if (!acc) return;
          const magnitude = Math.abs(acc.x || 0) + Math.abs(acc.y || 0) + Math.abs(acc.z || 0);
          if (magnitude < 42) return;
          const now = Date.now();
          if (now - lastShakeBlurAt < 900) return;
          lastShakeBlurAt = now;
          blurActiveField();
        };

        window.addEventListener("devicemotion", handleMotion);
      };

      blockSystemUndoActions();

      const autoResizeNote = (note) => {
        if (!note || note.tagName !== "TEXTAREA") return;
        note.style.height = "auto";
        const style = window.getComputedStyle(note);
        const lineHeight = parseFloat(style.lineHeight) || 14;
        const rows = Number(note.getAttribute("rows")) || 2;
        const minHeight = lineHeight * rows;
        const nextHeight = Math.max(note.scrollHeight, minHeight);
        note.style.height = `${nextHeight}px`;
      };

            const launchConfetti = () => {
        const layer = document.createElement("div");
        layer.className = "confetti-layer";
        document.documentElement.appendChild(layer);

        const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
        let latestEndAt = performance.now();
        const CONFETTI_STREAM_MS = 1400;
        const CONFETTI_BATCH_INTERVAL_MS = 180;
        const INITIAL_TROPHIES = 24;
        const BATCH_TROPHIES = 4;
        const MIN_FALL_SECONDS = 1.45;
        const FALL_SPREAD_SECONDS = 1.15;
        const MAX_START_DELAY_SECONDS = 0.18;
        const FINISH_BUFFER_MS = 8;

        const createTrophy = () => {
          const piece = document.createElement("span");
          piece.className = "confetti";
          piece.textContent = "\uD83C\uDFC6";

          // Willekeurige positie over hele breedte
          const x = Math.random() * viewportWidth;
          piece.style.left = x + "px";

          // Willekeurige grootte
          const size = 18 + Math.random() * 16;
          piece.style.fontSize = size + "px";

          // Snellere valsnelheid zodat lockscreen eerder kan tonen
          const fallDuration = MIN_FALL_SECONDS + Math.random() * FALL_SPREAD_SECONDS;
          piece.style.setProperty('--fall-duration', fallDuration + 's');

          // Kortere startdelay
          const delay = Math.random() * MAX_START_DELAY_SECONDS;
          piece.style.setProperty('--fall-delay', delay + 's');

          const endAt = performance.now() + (fallDuration + delay) * 1000;
          if (endAt > latestEndAt) latestEndAt = endAt;

          // Horizontale sway (-80px tot +80px)
          const sway = (Math.random() - 0.5) * 160;
          piece.style.setProperty('--sway', sway + 'px');

          // Subtielere rotaties voor trofeeën
          piece.style.setProperty('--spin-x', (Math.random() * 40 - 20) + 'deg');
          piece.style.setProperty('--spin-y', (Math.random() * 40 - 20) + 'deg');
          piece.style.setProperty('--spin-z', (Math.random() * 60 - 30) + 'deg');

          return piece;
        };

        const createTrophyBatch = (count) => {
          for (let i = 0; i < count; i++) {
            layer.appendChild(createTrophy());
          }
        };

        // Initiële burst
        createTrophyBatch(INITIAL_TROPHIES);

        return new Promise((resolve) => {
          let done = false;
          const finish = () => {
            if (done) return;
            done = true;
            layer.remove();
            resolve();
          };

          // Continue stroom, korter voor sneller lockscreen
          let elapsed = 0;
          const interval = setInterval(() => {
            elapsed += CONFETTI_BATCH_INTERVAL_MS;
            createTrophyBatch(BATCH_TROPHIES);

            if (elapsed >= CONFETTI_STREAM_MS) {
              clearInterval(interval);
              const waitMs = Math.max(0, latestEndAt - performance.now()) + FINISH_BUFFER_MS;
              setTimeout(finish, waitMs);
            }
          }, CONFETTI_BATCH_INTERVAL_MS);

          // Veiligheidsnet
          setTimeout(finish, 12500);
        });
      };


      if (!window.supabase) {
        console.error("Supabase library niet geladen!");
        return;
      }

      console.log("Supabase library gevonden, client aanmaken...");
      const supabase = window.supabase.createClient(
        "https://lqgcitosiyahgwqluwtb.supabase.co",
        "sb_publishable_dGMK5ruFsyWkF3ne43AS1A_lHURUBhI"
      );
      console.log("Supabase client aangemaakt");

      // Functie om sessie count op te halen en bij te werken
      const getSessionCount = async () => {
        try {
          const currentYear = new Date().getFullYear();
          const baselineCount = currentYear === 2026 ? 27 : 0;
          const { data, error } = await supabase
            .from("session_counts")
            .select("count")
            .eq("year", currentYear)
            .single();
          
          if (error) {
            // PGRST116 = geen resultaten gevonden
            if (error.code === 'PGRST116' || error.message?.includes('No rows')) {
              console.log("No session count found, creating new record");
              const { data: newData, error: insertError } = await supabase
                .from("session_counts")
                .insert({ year: currentYear, count: baselineCount })
                .select()
                .single();
              
              if (insertError) {
                console.error("Error creating session count:", insertError);
                return baselineCount; // Fallback
              }
              
              return newData?.count ?? baselineCount;
            } else {
              console.error("Error getting session count:", error);
              return baselineCount; // Fallback
            }
          }
          
          return data?.count ?? baselineCount;
        } catch (error) {
          console.error("Error in getSessionCount:", error);
          return new Date().getFullYear() === 2026 ? 27 : 0;
        }
      };

      const reconcileSessionCount = async (count) => {
        const currentYear = new Date().getFullYear();
        let target = count;

        if (currentYear === 2026 && target < 27) {
          target = 27;
        }

        if (target !== count) {
          const { error } = await supabase
            .from("session_counts")
            .upsert({ year: currentYear, count: target }, { onConflict: 'year' });

          if (error) {
            console.error("Error correcting session count:", error);
            return count;
          }
        }

        return target;
      };

      const updateSessionCount = async (increment = true) => {
        try {
          console.log(increment ? "incrementSessionCount called" : "decrementSessionCount called");
          const currentYear = new Date().getFullYear();
          console.log("Current year:", currentYear);
          
          const currentCount = await getSessionCount();
          console.log("Current count:", currentCount);
          
          const newCount = increment ? currentCount + 1 : Math.max(0, currentCount - 1);
          console.log("New count:", newCount);
          
          const { data, error } = await supabase
            .from("session_counts")
            .upsert({ year: currentYear, count: newCount }, { onConflict: 'year' });
          
          if (error) {
            console.error("Error updating session count:", error);
            if (error.message?.includes("Could not find the table") || error.message?.includes("relation") || error.message?.includes("does not exist")) {
              alert("De session_counts tabel bestaat nog niet in Supabase. Voer de SQL uit uit supabase.sql om de tabel aan te maken.");
            } else {
              alert("Fout bij updaten sessie count: " + error.message);
            }
            return;
          }
          
          console.log("Session count updated successfully:", data);
          updateSessionCountDisplay(newCount);
        } catch (error) {
          console.error("Error in updateSessionCount:", error);
          alert("Fout: " + error.message);
        }
      };

      const incrementSessionCount = () => updateSessionCount(true);
      const decrementSessionCount = () => updateSessionCount(false);

      const updateYearTotalFromList = () => {
        const list = document.querySelector(".year-modal__list");
        if (!list) return;
        const totalItem = list.querySelector(".year-total");
        if (!totalItem) return;

        let total = 0;
        list.querySelectorAll("li").forEach((item) => {
          if (item.classList.contains("year-total")) return;
          const text = item.textContent || "";
          const match = text.match(/(\d+)\s*$/);
          if (match) {
            total += Number.parseInt(match[1], 10);
          }
        });

        totalItem.innerHTML = `<strong>Totaal:</strong> ${total} sessies`;
      };


      const updateSessionCountDisplay = (count) => {
        const trainingCountEl = document.querySelector(".training-count");
        if (trainingCountEl) {
          const yearButton = trainingCountEl.querySelector(".year-trigger");
          const year = yearButton?.textContent?.replace(":", "") || new Date().getFullYear();
          trainingCountEl.innerHTML = `<button class="year-trigger" type="button">${year}:</button> ${count} sessies`;
          // Herstel de event listener na het updaten
          setupYearTrigger();

          const numericYear = Number(year);
          if (Number.isFinite(numericYear) && numericYear === 2026) {
            const yearItem = document.getElementById("yearCount2026");
            if (yearItem) {
              yearItem.innerHTML = `<strong>2026 (tot heden):</strong> ${count}`;
            }
          }
        }
        updateYearTotalFromList();
      };
      // Initialiseer sessie counts voor alle jaren (alleen als record nog niet bestaat)
      const initializeSessionCounts = async () => {
        const yearCounts = {
          2022: 18,
          2023: 14,
          2024: 22,
          2025: 301,
          2026: 27
        };

        for (const [year, count] of Object.entries(yearCounts)) {
          const { error } = await supabase
            .from("session_counts")
            .select("count")
            .eq("year", parseInt(year))
            .single();

          if (error) {
            if (error.code === 'PGRST116' || error.message?.includes('No rows')) {
              const { error: insertError } = await supabase
                .from("session_counts")
                .insert({ year: parseInt(year), count })
                .select()
                .single();

              if (insertError) {
                console.error(`Error inserting count for ${year}:`, insertError);
              } else {
                console.log(`Inserted count for ${year}: ${count}`);
              }
            } else {
              console.error(`Error fetching count for ${year}:`, error);
            }
          }
        }
      };

      // Laad de huidige sessie count en toon deze
      (async () => {
        await initializeSessionCounts();

        const count = await getSessionCount();
        let finalCount = await reconcileSessionCount(count);
        updateSessionCountDisplay(finalCount);
      })();

      const getPageDayNumber = () => {
        const hashDay = getHashDay();
        if (hashDay) {
          if (hashDay === "vandaag") return new Date().getDay();
          return daySlugToNumber[hashDay] ?? 1;
        }
        const path = window.location.pathname;
        if (path.includes("vandaag")) return new Date().getDay();
        if (path.includes("dinsdag")) return 2;
        if (path.includes("woensdag")) return 3;
        if (path.includes("donderdag")) return 4;
        if (path.includes("vrijdag")) return 5;
        if (path.includes("zaterdag")) return 6;
        if (path.includes("zondag")) return 0;
        return 1;
      };
      const todayNumber = new Date().getDay();
      const pageDayNumber = getPageDayNumber();
      const isToday = todayNumber === pageDayNumber;
      const sessionCompleteKey = `session_complete_${new Date().toLocaleDateString('en-CA')}`;
      document.body.classList.toggle("not-today", !isToday);
      const getCookie = (name) => {
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) return parts.pop().split(';').shift();
        return null;
      };
      const setCookie = (name, value) => {
        document.cookie = `${name}=${value}; Max-Age=31536000; Path=/; SameSite=Lax`;
      };
      const clearCookie = (name) => {
        document.cookie = `${name}=; Max-Age=0; Path=/; SameSite=Lax`;
      };
      // Setup session check button
      window.addEventListener("DOMContentLoaded", () => {
        const sessionCheckButton = document.getElementById("sessionCheckButton");
        if (!sessionCheckButton) return;
        const dayNames = ["Zondag", "Maandag", "Dinsdag", "Woensdag", "Donderdag", "Vrijdag", "Zaterdag"];
        const sessionDay = dayNames[pageDayNumber];
        // Toon knop alleen als het vandaag is en geen rustdag
        if (!isToday || sessionDay === "Vrijdag") {
          return;
        }
        // Toon de knop
        sessionCheckButton.classList.add("is-today");
        const todayStr = new Date().toLocaleDateString('en-CA');
                const storageKey = "session-checked-" + todayStr;
                const sessionCompleteKey = `session_complete_${todayStr}`;
                const ensureSessionLockStyles = () => {
                  if (document.getElementById("sessionLockStyles")) return;
                  const style = document.createElement("style");
                  style.id = "sessionLockStyles";
                  style.textContent = `
                    .session-lock-overlay {
                      position: fixed;
                      inset: 0;
                      display: none;
                      align-items: center;
                      justify-content: center;
                      padding: 24px 24px calc(24px + env(safe-area-inset-bottom));
                      background: rgba(0, 0, 0, 0.22);
                      isolation: isolate;
                      backdrop-filter: blur(3px) saturate(82%) brightness(96%);
                      -webkit-backdrop-filter: blur(3px) saturate(82%) brightness(96%);
                      z-index: 12000;
                      pointer-events: all;
                      opacity: 0;
                      transition: opacity 0.24s cubic-bezier(0.4, 0, 0.2, 1);
                    }

                    .session-lock-overlay.is-visible {
                      opacity: 1;
                    }

                    .session-lock-overlay::before {
                      content: "";
                      position: absolute;
                      inset: 0;
                      background: radial-gradient(ellipse at center, transparent 35%, rgba(0, 0, 0, 0.18) 100%);
                      pointer-events: none;
                      z-index: 0;
                    }

                    .session-lock-overlay::after {
                      content: "";
                      position: absolute;
                      left: 0;
                      right: 0;
                      bottom: 0;
                      height: calc(120px + env(safe-area-inset-bottom));
                      background: linear-gradient(180deg, rgba(21, 24, 29, 0) 0%, rgba(21, 24, 29, 0.95) 100%);
                      pointer-events: none;
                      z-index: 0;
                    }

                    .session-lock-card {
                      position: relative;
                      z-index: 1;
                      width: min(100% - 40px, 340px);
                      border-radius: 24px;
                      padding: 40px 28px 32px;
                      text-align: center;
                      background:
                        linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.02) 100%),
                        rgba(16, 20, 28, 0.82);
                      backdrop-filter: blur(40px) saturate(160%);
                      -webkit-backdrop-filter: blur(40px) saturate(160%);
                      border: 1px solid rgba(255, 255, 255, 0.09);
                      box-shadow:
                        0 0 0 1px rgba(255, 255, 255, 0.04),
                        0 4px 16px rgba(0, 0, 0, 0.18),
                        0 16px 48px rgba(0, 0, 0, 0.22),
                        0 32px 80px rgba(0, 0, 0, 0.12),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1),
                        inset 0 -1px 0 rgba(255, 255, 255, 0.03);
                      transform: scale(0.94) translateY(10px);
                      opacity: 0;
                      transition:
                        transform 0.34s cubic-bezier(0.16, 1, 0.3, 1),
                        opacity 0.26s ease;
                    }

                    .session-lock-overlay.is-visible .session-lock-card {
                      transform: scale(1) translateY(0);
                      opacity: 1;
                    }

                    .session-lock-card::after {
                      content: "";
                      position: absolute;
                      inset: 0;
                      border-radius: 24px;
                      background: linear-gradient(
                        105deg,
                        transparent 38%,
                        rgba(255, 255, 255, 0.04) 44%,
                        rgba(255, 255, 255, 0.08) 50%,
                        rgba(255, 255, 255, 0.04) 56%,
                        transparent 62%
                      );
                      background-size: 250% 100%;
                      animation: lockShimmer 4s ease-in-out infinite;
                      pointer-events: none;
                    }

                    @keyframes lockShimmer {
                      0% { background-position: 200% 0; }
                      100% { background-position: -200% 0; }
                    }

                    .session-lock-badge {
                      width: 64px;
                      height: 64px;
                      margin: 0 auto 22px;
                      border-radius: 50%;
                      display: grid;
                      place-items: center;
                      background:
                        radial-gradient(circle at 35% 28%, rgba(74, 163, 255, 0.35), transparent 60%),
                        linear-gradient(150deg, rgba(74, 163, 255, 0.18), rgba(46, 160, 67, 0.12));
                      border: 1px solid rgba(74, 163, 255, 0.28);
                      box-shadow:
                        0 0 20px rgba(74, 163, 255, 0.12),
                        0 8px 24px rgba(0, 0, 0, 0.18),
                        inset 0 1px 0 rgba(255, 255, 255, 0.12);
                      animation: badgeGlow 3.5s ease-in-out infinite;
                    }

                    @keyframes badgeGlow {
                      0%, 100% {
                        box-shadow:
                          0 0 20px rgba(74, 163, 255, 0.12),
                          0 8px 24px rgba(0, 0, 0, 0.18),
                          inset 0 1px 0 rgba(255, 255, 255, 0.12);
                      }
                      50% {
                        box-shadow:
                          0 0 32px rgba(74, 163, 255, 0.22),
                          0 8px 24px rgba(0, 0, 0, 0.18),
                          inset 0 1px 0 rgba(255, 255, 255, 0.12);
                      }
                    }

                    .session-lock-badge svg {
                      width: 28px;
                      height: 28px;
                      stroke: #7ab8ff;
                      stroke-width: 2.5;
                      fill: none;
                      stroke-linecap: round;
                      stroke-linejoin: round;
                      filter: drop-shadow(0 0 5px rgba(74, 163, 255, 0.25));
                    }

                    .session-lock-title {
                      margin: 0 0 8px;
                      color: #f0f4f8;
                      font-size: 1.18rem;
                      font-weight: 700;
                      letter-spacing: -0.01em;
                      line-height: 1.25;
                    }

                    .session-lock-copy {
                      margin: 0 0 22px;
                      color: rgba(195, 208, 225, 0.72);
                      font-size: 0.84rem;
                      line-height: 1.5;
                    }

                    .session-lock-divider {
                      height: 1px;
                      margin: 0 auto 18px;
                      width: 44px;
                      background: linear-gradient(90deg, transparent, rgba(74, 163, 255, 0.35), transparent);
                    }

                    .session-lock-chip {
                      display: inline-flex;
                      align-items: center;
                      gap: 6px;
                      border-radius: 999px;
                      border: 1px solid rgba(46, 160, 67, 0.3);
                      padding: 6px 14px;
                      color: rgba(130, 220, 155, 0.92);
                      font-size: 0.7rem;
                      font-weight: 600;
                      letter-spacing: 0.05em;
                      text-transform: uppercase;
                      background: rgba(46, 160, 67, 0.08);
                    }

                    .session-lock-chip::before {
                      content: "";
                      width: 6px;
                      height: 6px;
                      border-radius: 50%;
                      background: #4ade80;
                      box-shadow: 0 0 8px rgba(74, 222, 128, 0.4);
                    }

                    @media (max-width: 540px) {
                      .session-lock-overlay {
                        padding: 20px 20px calc(20px + env(safe-area-inset-bottom));
                      }

                      .session-lock-card {
                        padding: 32px 22px 26px;
                        border-radius: 20px;
                      }

                      .session-lock-card::after {
                        border-radius: 20px;
                      }

                      .session-lock-badge {
                        width: 56px;
                        height: 56px;
                        margin-bottom: 18px;
                      }

                      .session-lock-badge svg {
                        width: 24px;
                        height: 24px;
                      }

                      .session-lock-title {
                        font-size: 1.08rem;
                      }

                      .session-lock-copy {
                        font-size: 0.8rem;
                      }
                    }
                  `;
                  document.head.appendChild(style);
                };
                const ensureSessionLockOverlay = () => {
                  let overlay = document.getElementById("sessionLockOverlay");
                  if (overlay) return overlay;
                  ensureSessionLockStyles();
                  overlay = document.createElement("div");
                  overlay.id = "sessionLockOverlay";
                  overlay.className = "session-lock-overlay";
                  overlay.setAttribute("role", "alertdialog");
                  overlay.setAttribute("aria-modal", "true");
                  overlay.setAttribute("aria-label", "Sessie vergrendeld");
                  overlay.setAttribute("aria-hidden", "true");
                  overlay.tabIndex = -1;
                  overlay.innerHTML = `
                    <div class="session-lock-card">
                      <div class="session-lock-badge" aria-hidden="true">
                        <svg viewBox="0 0 24 24"><path d="M20 6L9 17l-5-5"/></svg>
                      </div>
                      <h2 class="session-lock-title">Sessie Afgerond</h2>
                      <p class="session-lock-copy">Je training staat vast. Alles blijft zichtbaar, bewerkingen zijn vergrendeld tot morgen.</p>
                      <div class="session-lock-divider" aria-hidden="true"></div>
                      <div class="session-lock-chip">Voltooid</div>
                    </div>
                  `;
                  overlay.addEventListener("click", (event) => {
                    if (event.target !== overlay) return;
                    overlay.style.display = "none";
                    overlay.setAttribute("aria-hidden", "true");
                  });
                  document.body.appendChild(overlay);
                  return overlay;
                };
                const setSessionLocked = (locked) => {
                  const overlay = ensureSessionLockOverlay();
                  if (locked) {
                    overlay.style.display = "flex";
                    requestAnimationFrame(() => {
                      overlay.classList.add("is-visible");
                    });
                    overlay.setAttribute("aria-hidden", "false");
                    if (document.activeElement instanceof HTMLElement) {
                      document.activeElement.blur();
                    }
                    overlay.focus({ preventScroll: true });
                    overlay._focusTrap = (e) => {
                      if (e.key === "Tab") {
                        e.preventDefault();
                        overlay.focus({ preventScroll: true });
                      }
                    };
                    document.addEventListener("keydown", overlay._focusTrap);
                  } else {
                    overlay.classList.remove("is-visible");
                    overlay.setAttribute("aria-hidden", "true");
                    if (overlay._focusTrap) {
                      document.removeEventListener("keydown", overlay._focusTrap);
                      delete overlay._focusTrap;
                    }
                    setTimeout(() => {
                      overlay.style.display = "none";
                    }, 350);
                  }
                };
                const isMissingDateColumn = (error) => {
                  const msg = error?.message || "";
                  return msg.includes("column") && msg.includes("date") && msg.includes("does not exist");
                };
                const fetchSessionStatus = async () => {
                  let { data, error } = await supabase
                    .from("workout_entries")
                    .select("completed, date, updated_at")
                    .eq("day", sessionDay)
                    .eq("exercise_index", 0)
                    .maybeSingle();
                  if (error && isMissingDateColumn(error)) {
                    ({ data, error } = await supabase
                      .from("workout_entries")
                      .select("completed, updated_at")
                      .eq("day", sessionDay)
                      .eq("exercise_index", 0)
                      .maybeSingle());
                  }
                  return { data, error };
                };
                const saveSessionStatus = async (completed) => {
                  const basePayload = {
                    day: sessionDay,
                    exercise_index: 0,
                    completed,
                    updated_at: new Date().toISOString()
                  };
                  let { error } = await supabase
                    .from("workout_entries")
                    .upsert({ ...basePayload, date: todayStr }, { onConflict: "day,exercise_index" });
                  if (error && isMissingDateColumn(error)) {
                    ({ error } = await supabase
                      .from("workout_entries")
                      .upsert(basePayload, { onConflict: "day,exercise_index" }));
                  }
                  return error;
                };
                const hasLocalSessionComplete = () => {
                  const localValue = localStorage.getItem(storageKey);
                  const cookieValue = getCookie(storageKey);
                  const localCompleteValue = localStorage.getItem(sessionCompleteKey);
                  return localCompleteValue === "1" || localValue === "1" || cookieValue === "1";
                };
                // Herstel status bij laden
                const restoreStatus = async () => {
                  let isComplete = false;
                  const countIncrementedKey = `session-count-incremented-${todayStr}`;
                  if (hasLocalSessionComplete()) {
                    isComplete = true;
                    sessionCheckButton.classList.add("is-complete");
                    setSessionLocked(true);
                  }
                  try {
                    const { data, error } = await fetchSessionStatus();
                    if (!error && data) {
                      const entryDate = data.date ? new Date(data.date).toLocaleDateString('en-CA') : null;
                      const updatedDate = data.updated_at ? new Date(data.updated_at).toLocaleDateString('en-CA') : null;
                      const matchesToday = entryDate
                        ? entryDate === todayStr
                        : (updatedDate ? updatedDate === todayStr : false);
                      if (matchesToday && data.completed) {
                        isComplete = true;
                        localStorage.setItem(storageKey, "1");
                        localStorage.setItem(sessionCompleteKey, "1");
                        setCookie(storageKey, "1");
                      } else if ((entryDate && entryDate !== todayStr) || (!entryDate && updatedDate && updatedDate !== todayStr)) {
                        await saveSessionStatus(false);
                        isComplete = false;
                        localStorage.removeItem(countIncrementedKey);
                      }
                    } else if (!error) {
                      if (hasLocalSessionComplete()) {
                        isComplete = true;
                        await saveSessionStatus(true);
                      }
                    } else {
                      if (hasLocalSessionComplete()) {
                        isComplete = true;
                      }
                    }
                  } catch (e) {
                    console.error("Error checking session status:", e);
                    if (hasLocalSessionComplete()) {
                      isComplete = true;
                    }
                  }
                  // Update UI
                  if (isComplete) {
                    sessionCheckButton.classList.add("is-complete");
                  } else {
                    sessionCheckButton.classList.remove("is-complete");
                    // Verwijder oude localStorage entries van andere dagen
                    const keysToRemove = [];
                    for (let i = 0; i < localStorage.length; i++) {
                      const key = localStorage.key(i);
                      if (key && (key.startsWith("session-checked-") || key.startsWith("session_complete_") || key.startsWith("session-count-incremented-"))) {
                        const keyDate = key.split("-").pop() || key.split("_").pop();
                        if (keyDate && keyDate !== todayStr) {
                          keysToRemove.push(key);
                        }
                      }
                    }
                    keysToRemove.forEach(key => localStorage.removeItem(key));
                  }
                  setSessionLocked(isComplete);
                };
                if (hasLocalSessionComplete()) {
                  sessionCheckButton.classList.add("is-complete");
                  setSessionLocked(true);
                }

                // Wacht even zodat Supabase is geïnitialiseerd
                setTimeout(() => {
                  restoreStatus();
                }, 100);
                // Toggle functie
                let lastToggleAt = 0;
                const triggerCompletionHaptic = (() => {
                  let iosToggleState = false;

                  const triggerVibrationApi = () => {
                    if (typeof navigator.vibrate !== "function") return false;
                    try {
                      // Iets langer patroon zodat het op Android duidelijk voelbaar is.
                      const didVibrate = navigator.vibrate([40, 30, 70]);
                      return didVibrate !== false;
                    } catch (error) {
                      return false;
                    }
                  };

                  const triggerIosSwitchHaptic = () => {
                    try {
                      // iOS/Safari fallback: hidden switch + label click (werkt beter dan input.click()).
                      const wrapper = document.createElement("div");
                      wrapper.style.position = "fixed";
                      wrapper.style.left = "-9999px";
                      wrapper.style.top = "-9999px";
                      wrapper.style.width = "1px";
                      wrapper.style.height = "1px";
                      wrapper.style.opacity = "0";
                      wrapper.style.pointerEvents = "none";
                      wrapper.style.overflow = "hidden";

                      const switchInput = document.createElement("input");
                      switchInput.type = "checkbox";
                      switchInput.setAttribute("switch", "");
                      switchInput.setAttribute("aria-hidden", "true");
                      switchInput.tabIndex = -1;
                      switchInput.checked = iosToggleState;
                      iosToggleState = !iosToggleState;

                      const switchId = `haptic-switch-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
                      switchInput.id = switchId;

                      const switchLabel = document.createElement("label");
                      switchLabel.setAttribute("for", switchId);
                      switchLabel.setAttribute("aria-hidden", "true");
                      switchLabel.tabIndex = -1;
                      switchLabel.style.display = "block";
                      switchLabel.style.width = "1px";
                      switchLabel.style.height = "1px";

                      wrapper.appendChild(switchInput);
                      wrapper.appendChild(switchLabel);
                      document.body.appendChild(wrapper);

                      switchLabel.click();
                      setTimeout(() => wrapper.remove(), 64);
                      return true;
                    } catch (error) {
                      return false;
                    }
                  };

                  const triggerNativeBridgeHaptic = () => {
                    try {
                      const handlers = window.webkit && window.webkit.messageHandlers ? window.webkit.messageHandlers : null;
                      if (!handlers) return false;
                      if (handlers.haptic && typeof handlers.haptic.postMessage === "function") {
                        handlers.haptic.postMessage({ type: "impact", style: "light" });
                        return true;
                      }
                      if (handlers.vibrate && typeof handlers.vibrate.postMessage === "function") {
                        handlers.vibrate.postMessage({ duration: 70 });
                        return true;
                      }
                    } catch (error) {
                      return false;
                    }
                    return false;
                  };

                  return () => {
                    if (triggerVibrationApi()) return;
                    if (triggerIosSwitchHaptic()) return;
                    triggerNativeBridgeHaptic();
                  };
                })();

                const toggleSession = async (e) => {
                  if (e && e.cancelable) e.preventDefault();
                  if (e) e.stopPropagation();
                  const now = Date.now();
                  if (now - lastToggleAt < 600) return;
                  lastToggleAt = now;
                  const wasComplete = sessionCheckButton.classList.contains("is-complete");
                  const isComplete = sessionCheckButton.classList.toggle("is-complete");
                  const countIncrementedKey = `session-count-incremented-${todayStr}`;
                  if (isComplete && !wasComplete) {
                    // Markeren als compleet
                    localStorage.setItem(sessionCompleteKey, "1");
                    localStorage.setItem(storageKey, "1");
                    setCookie(storageKey, "1");
                    triggerCompletionHaptic();
                    const saveError = await saveSessionStatus(true);
                    if (saveError) {
                      console.error("Error saving session status to Supabase:", saveError);
                    }
                                        if (!localStorage.getItem(countIncrementedKey)) {
                      const confettiDone = launchConfetti();
                      const countUpdate = incrementSessionCount();
                      localStorage.setItem(countIncrementedKey, "1");
                      await confettiDone;
                      if (sessionCheckButton.classList.contains("is-complete")) {
                        setSessionLocked(true);
                      }
                      await countUpdate;
                    } else {
                      setSessionLocked(true);
                    }

                  } else if (!isComplete && wasComplete) {
                    // Unmarkeren
                    localStorage.removeItem(sessionCompleteKey);
                    localStorage.removeItem(storageKey);
                    localStorage.removeItem(countIncrementedKey);
                    clearCookie(storageKey);
                    const saveError = await saveSessionStatus(false);
                    if (saveError) {
                      console.error("Error saving session status to Supabase:", saveError);
                    }
                    await decrementSessionCount();
                    setSessionLocked(false);
                  }
              };
                // Event listeners
                sessionCheckButton.addEventListener("click", toggleSession);
                sessionCheckButton.addEventListener("touchend", toggleSession, { passive: false });
              });
      // Bepaal de dag naam op basis van het bestand voor Supabase
      const getDayName = () => {
        const hashDay = getHashDay();
        if (hashDay) {
          if (hashDay === "vandaag") {
            const dayNames = ["Zondag", "Maandag", "Dinsdag", "Woensdag", "Donderdag", "Vrijdag", "Zaterdag"];
            return dayNames[new Date().getDay()];
          }
          return daySlugToName[hashDay] || "Maandag";
        }
        const path = window.location.pathname;
        if (path.includes("vandaag")) {
          const dayNames = ["Zondag", "Maandag", "Dinsdag", "Woensdag", "Donderdag", "Vrijdag", "Zaterdag"];
          return dayNames[new Date().getDay()];
        }
                if (path.includes("dinsdag")) return "Dinsdag";
                if (path.includes("woensdag")) return "Woensdag";
                if (path.includes("donderdag")) return "Donderdag";
                if (path.includes("vrijdag")) return "Vrijdag";
                if (path.includes("zaterdag")) return "Zaterdag";
                if (path.includes("zondag")) return "Zondag";
                return "Maandag"; // default voor maandag
              };
              let day = getDayName();
              const REST_DAY_NAME = "Vrijdag";
              let dayToken = 0;
              const getCurrentRows = () => Array.from(document.querySelectorAll(".row"));
              const ensureHeaderRow = () => {
                const grid = document.querySelector(".grid");
                if (!grid) return null;
                let headerRow = grid.querySelector(".header-row");
                if (headerRow) return headerRow;
                headerRow = document.createElement("div");
                headerRow.className = "header-row";
                headerRow.innerHTML = `
                  <div class="header exercise-header"></div>
                  <div class="header">SETS</div>
                  <div class="header">REPS</div>
                  <div class="header">KG</div>
                `;
                grid.prepend(headerRow);
                return headerRow;
              };
              const setHeaderRowVisible = (visible) => {
                const headerRow = document.querySelector(".header-row");
                if (!headerRow) return;
                headerRow.style.display = visible ? "" : "none";
              };
              const renderRestDay = () => {
                const grid = document.querySelector(".grid");
                if (!grid) return;
                grid.classList.add("rest-day");
                grid.setAttribute("aria-label", "Vrije dag");
                setHeaderRowVisible(false);
                grid.querySelectorAll(".row").forEach((row) => row.remove());
                const restRow = document.createElement("div");
                restRow.className = "row";
                restRow.innerHTML = `
                  <div class="exercise-cell">
                    <div class="exercise-name">Vrije dag</div>
                    <div class="exercise-note">Herstel &amp; rust</div>
                  </div>
                `;
                grid.appendChild(restRow);
              };
              const clearRestDay = () => {
                const grid = document.querySelector(".grid");
                if (!grid) return;
                grid.classList.remove("rest-day");
                grid.setAttribute("aria-label", "Oefeningen");
                setHeaderRowVisible(true);
                // verwijder eventuele rest-day rows zonder inputs
                grid.querySelectorAll(".row").forEach((row) => {
                  if (!row.querySelector("input")) row.remove();
                });
                ensureHeaderRow();
              };
              const resetRowsForLoad = () => {
                getCurrentRows().forEach((row) => {
                  row.querySelectorAll("input, textarea").forEach((input) => {
                    input.value = "";
                    delete input.dataset.userSet;
                    if (input.classList.contains("exercise-note")) {
                      autoResizeNote(input);
                    }
                  });
                });
              };
              if (!day || getCurrentRows().length === 0) return;
              const getRowIndex = (row) => getCurrentRows().indexOf(row);
              const DEFAULTS_STORAGE_KEY = "exercise_defaults_v1";
              const exerciseDefaultsCache = (() => {
                try {
                  const raw = localStorage.getItem(DEFAULTS_STORAGE_KEY);
                  const parsed = raw ? JSON.parse(raw) : {};
                  return new Map(Object.entries(parsed));
                } catch (e) {
                  return new Map();
                }
      })();

      const fetchedDefaults = new Set();

      const persistDefaultsCache = () => {
        try {
          const obj = Object.fromEntries(exerciseDefaultsCache.entries());
          localStorage.setItem(DEFAULTS_STORAGE_KEY, JSON.stringify(obj));
        } catch (e) {
          // ignore
        }
      };

      const normalizeExerciseName = (name) => (name || "").trim().toLowerCase();
      const escapeIlike = (value) => value.replace(/[\\%_]/g, "\\$&");

      const fetchExerciseDefaults = async (rawName) => {
        const name = (rawName || "").trim();
        if (!name) return null;
        const key = normalizeExerciseName(name);
        const cached = exerciseDefaultsCache.get(key) ?? null;
        if (cached && fetchedDefaults.has(key)) return cached;

        const pattern = escapeIlike(name);
        const { data, error } = await supabase
          .from("workout_entries")
          .select("sets,reps,weight,note,updated_at")
          .ilike("exercise_name", pattern)
          .order("updated_at", { ascending: false })
          .limit(1)
          .maybeSingle();

        const { data: noteData, error: noteError } = await supabase
          .from("workout_entries")
          .select("note,updated_at")
          .ilike("exercise_name", pattern)
          .not("note", "is", null)
          .neq("note", "")
          .order("updated_at", { ascending: false })
          .limit(1)
          .maybeSingle();

        if (error) {
          console.error("Supabase defaults load failed:", error);
          return cached;
        }
        if (noteError) {
          console.error("Supabase note defaults load failed:", noteError);
        }
        const resolvedNote = noteData?.note ?? data?.note ?? null;
        const defaults = data ? { sets: data.sets, reps: data.reps, weight: data.weight, note: resolvedNote } : (resolvedNote != null ? { sets: null, reps: null, weight: null, note: resolvedNote } : null);
        exerciseDefaultsCache.set(key, defaults);
        fetchedDefaults.add(key);
        persistDefaultsCache();
        return defaults;
      };

      const updateDefaultsCache = (payload) => {
        if (!payload || !payload.exercise_name) return;
        const key = normalizeExerciseName(payload.exercise_name);
        if (!key) return;
        const existing = exerciseDefaultsCache.get(key) || {};
        const nextNote = payload.note != null && String(payload.note).trim() !== "" ? payload.note : existing.note ?? null;
        exerciseDefaultsCache.set(key, { sets: payload.sets, reps: payload.reps, weight: payload.weight, note: nextNote });
        fetchedDefaults.add(key);
        persistDefaultsCache();
      };

      const applyExerciseDefaults = async (row) => {
        if (!row) return;
        const nameInput = row.querySelector(".exercise-name");
        const noteInput = row.querySelector(".exercise-note");
        if (!nameInput) return;
        const name = nameInput.value?.trim();
        if (!name) return;

        const defaults = await fetchExerciseDefaults(name);
        if (!defaults) return;

        const setsInput = row.querySelector('input[name^="sets-"]');
        const repsInput = row.querySelector('input[name^="reps-"]');
        const weightInput = row.querySelector('input[name^="gewicht-"]');

        const maybeApply = (input, value) => {
          if (!input) return;
          if (input.dataset.userSet === "1") return;
          if (value == null || value === "") return;
          input.value = String(value);
        };

        maybeApply(setsInput, defaults.sets);
        maybeApply(repsInput, defaults.reps);
        maybeApply(weightInput, defaults.weight);
        if (noteInput) {
          const hasValue = noteInput.value != null && String(noteInput.value).trim() !== "";
          if (!hasValue) {
            maybeApply(noteInput, defaults.note);
          }
          autoResizeNote(noteInput);
        }
      };

      const defaultsTimers = new WeakMap();
      const scheduleDefaults = (row) => {
        if (!row) return;
        const existingTimer = defaultsTimers.get(row);
        if (existingTimer) clearTimeout(existingTimer);
        const timer = setTimeout(() => {
          applyExerciseDefaults(row);
        }, 300);
        defaultsTimers.set(row, timer);
      };

      const applyDefaultsForAllRows = () => {
        getCurrentRows().forEach((row) => {
          scheduleDefaults(row);
        });
      };

      const toNumber = (value) => {
        if (value === "" || value == null) return null;
        const num = Number(value);
        return Number.isNaN(num) ? null : num;
      };

      const getRowData = (row, index) => {
        const nameInput = row.querySelector(".exercise-name");
        const noteInput = row.querySelector(".exercise-note");
        const setsInput = row.querySelector('input[name^="sets-"]');
        const repsInput = row.querySelector('input[name^="reps-"]');
        const weightInput = row.querySelector('input[name^="gewicht-"]');

        return {
          day,
          exercise_index: index + 1,
          exercise_name: nameInput?.value?.trim() || null,
          note: noteInput?.value?.trim() || null,
          sets: toNumber(setsInput?.value),
          reps: toNumber(repsInput?.value),
          weight: toNumber(weightInput?.value),
          updated_at: new Date().toISOString(),
        };
      };

      const WORKOUT_CACHE_PREFIX = "workout_cache_v1:";
      const getCachedWorkoutData = (dayName) => {
        if (!dayName) return null;
        try {
          const raw = localStorage.getItem(`${WORKOUT_CACHE_PREFIX}${dayName}`);
          if (!raw) return null;
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) return parsed;
          if (parsed && Array.isArray(parsed.data)) return parsed.data;
          return null;
        } catch (e) {
          return null;
        }
      };
      const setCachedWorkoutData = (dayName, data) => {
        if (!dayName || !Array.isArray(data) || data.length === 0) return;
        try {
          localStorage.setItem(
            `${WORKOUT_CACHE_PREFIX}${dayName}`,
            JSON.stringify({ ts: Date.now(), data })
          );
        } catch (e) {
          // ignore
        }
      };
      const normalizeEntry = (item, index, dayName) => ({
        day: dayName,
        exercise_index: Number(item?.exercise_index) || index + 1,
        exercise_name: item?.exercise_name ?? null,
        note: item?.note ?? null,
        sets: toNumber(item?.sets),
        reps: toNumber(item?.reps),
        weight: toNumber(item?.weight),
        updated_at: item?.updated_at || new Date().toISOString(),
      });

      const templateRows = (() => {
        try {
          return getCurrentRows().map((row, idx) => {
            const data = getRowData(row, idx);
            return {
              exercise_name: data.exercise_name,
              note: data.note,
              sets: data.sets,
              reps: data.reps,
              weight: data.weight,
            };
          });
        } catch (e) {
          return [];
        }
      })();

      const upsertRow = async (row, index) => {
        if (index == null || index < 0) return;
        const payload = getRowData(row, index);
        updateDefaultsCache(payload);
        console.log("Saving data:", payload);
        const { data, error } = await supabase
          .from("workout_entries")
          .upsert(payload, { onConflict: "day,exercise_index" })
          .select();
        if (error) {
          console.error("Supabase save failed:", error);
          console.error("Payload was:", payload);
        } else {
          console.log("Saved successfully:", data);
        }
      };

      const getColumnForInput = (input) => {
        if (input.classList.contains("exercise-name")) return "exercise_name";
        if (input.classList.contains("exercise-note")) return "note";
        const name = input.getAttribute("name") || "";
        if (name.startsWith("sets-")) return "sets";
        if (name.startsWith("reps-")) return "reps";
        if (name.startsWith("gewicht-")) return "weight";
        return null;
      };

      const clearField = async (row, input) => {
        const column = getColumnForInput(input);
        if (!column) return;
        const index = getRowIndex(row);
        if (index < 0) return;
        const { error } = await supabase
          .from("workout_entries")
          .update({ [column]: null })
          .match({ day, exercise_index: index + 1 });
        if (error) console.warn("Supabase clear failed", error);
      };

      const timers = new WeakMap();
      const scheduleSave = (row, immediate = false) => {
        if (!row) return;
        if (!hasDataLoaded) return;
        const existingTimer = timers.get(row);
        if (existingTimer) clearTimeout(existingTimer);
        const delay = immediate ? 0 : 500;
        const timer = setTimeout(() => {
          const index = getRowIndex(row);
          if (index < 0) return;
          upsertRow(row, index);
        }, delay);
        timers.set(row, timer);
      };

      // Functie om alle rows opnieuw te indexeren en op te slaan
      const reindexAndSaveAllRows = async () => {
        console.log("reindexAndSaveAllRows aangeroepen voor dag:", day);
        if (!hasDataLoaded) {
          console.warn("Data nog niet geladen, herindexeer opslaan overgeslagen");
          return;
        }
        if (!day) {
          console.warn("Geen dag gevonden, overslaan");
          return;
        }
        const allRows = Array.from(document.querySelectorAll(".row"));
        console.log("Aantal rows:", allRows.length);

        const payload = allRows.map((row, index) => getRowData(row, index));
        payload.forEach(updateDefaultsCache);

        if (!payload.length) {
          const { error: deleteError } = await supabase
            .from("workout_entries")
            .delete()
            .eq("day", day);
          if (deleteError) {
            console.error("Fout bij verwijderen oude entries:", deleteError);
          } else {
            console.log("Alle entries verwijderd (geen rows meer)");
          }
          updateDynamicLayout();
          return;
        }

        const { error: upsertError } = await supabase
          .from("workout_entries")
          .upsert(payload, { onConflict: "day,exercise_index" });
        if (upsertError) {
          console.error("Fout bij opslaan geherindexeerde rows:", upsertError);
          return;
        }
        setCachedWorkoutData(day, payload);

        const { error: cleanupError } = await supabase
          .from("workout_entries")
          .delete()
          .eq("day", day)
          .gt("exercise_index", payload.length);
        if (cleanupError) {
          console.error("Fout bij opruimen oude rows:", cleanupError);
        } else {
          console.log("Alle rows opnieuw opgeslagen");
        }

        updateDynamicLayout();
      };

      // Functie om event listeners toe te voegen aan een row
      const attachRowEventListeners = (row) => {
        row.querySelectorAll("input, textarea").forEach((input) => {
          input.addEventListener("input", (event) => {
            if (event.isTrusted) {
              const column = getColumnForInput(input);
              if (column === "sets" || column === "reps" || column === "weight" || column === "note") {
                input.dataset.userSet = "1";
              }
            }
            if (input.classList.contains("exercise-note")) {
              autoResizeNote(input);
            }
            if (input.classList.contains("exercise-name")) {
              scheduleDefaults(row);
            }
            const value = input.value ?? "";
            if (value === "") {
              clearField(row, input);
              scheduleSave(row, true);
              return;
            }
            scheduleSave(row, false);
          });
          input.addEventListener("blur", () => {
            if (input.classList.contains("exercise-name")) {
              applyExerciseDefaults(row).finally(() => {
                scheduleSave(row, true);
              });
              return;
            }
            scheduleSave(row, true);
          });
        });
      };

      const buildRow = (displayIndex) => {
        const row = document.createElement("div");
        row.className = "row";
        row.innerHTML = `
            <div class="exercise-cell">
              <button class="drag-handle" type="button" aria-label="Verplaats oefening"></button>
              <input spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off" class="exercise-name" type="text" name="oefening-${displayIndex}" placeholder="Geef je oefening een naam" />
              <textarea spellcheck="false" autocapitalize="off" autocomplete="off" autocorrect="off" class="exercise-note" name="note-${displayIndex}" rows="2"></textarea>
            </div>
            <div class="mini-wrap" data-label="Sets">
              <input type="text" class="mini-field" name="sets-${displayIndex}" data-max="9" inputmode="numeric" pattern="[0-9]*" maxlength="1" value="3" />
            </div>
            <div class="mini-wrap" data-label="Reps">
              <input type="text" class="mini-field" name="reps-${displayIndex}" data-max="30" inputmode="numeric" pattern="[0-9]*" maxlength="2" />
            </div>
            <div class="mini-wrap" data-label="Gewicht">
              <input type="text" class="mini-field" name="gewicht-${displayIndex}" data-max="999" inputmode="numeric" pattern="[0-9]*" maxlength="3" />
            </div>
          `;
        return row;
      };

      const insertRowAtEnd = (row) => {
        const grid = document.querySelector(".grid");
        if (!grid || !row) return;
        const rows = getCurrentRows();
        if (rows.length > 0) {
          rows[rows.length - 1].after(row);
          return;
        }
        const headerRow = document.querySelector(".header-row");
        if (headerRow) {
          headerRow.after(row);
        } else {
          grid.appendChild(row);
        }
      };

      const insertRowBeforeLast = (row) => {
        const grid = document.querySelector(".grid");
        if (!grid || !row) return;
        const rows = getCurrentRows();
        if (rows.length === 0) {
          const headerRow = document.querySelector(".header-row");
          if (headerRow) {
            headerRow.after(row);
          } else {
            grid.appendChild(row);
          }
          return;
        }
        rows[rows.length - 1].before(row);
      };

      const insertRowBeforeSelected = (row, selectedRow) => {
        if (!row) return false;
        if (selectedRow && selectedRow.parentNode) {
          selectedRow.before(row);
          return true;
        }
        return false;
      };

      const ensureRowHandle = (row) => {
        const cell = row.querySelector(".exercise-cell");
        if (!cell) return;
        if (cell.querySelector(".drag-handle")) return;
        const handle = document.createElement("button");
        handle.className = "drag-handle";
        handle.type = "button";
        handle.setAttribute("aria-label", "Verplaats oefening");
        cell.prepend(handle);
      };

      const initRow = (row) => {
        if (!row) return;
        ensureRowHandle(row);
        row.querySelectorAll("input[data-max]").forEach(clampInput);
        row.querySelectorAll(".mini-field").forEach(cursorToEnd);
        row.querySelectorAll(".exercise-note").forEach(autoResizeNote);
        attachRowEventListeners(row);
        if (typeof attachTouchListeners === "function") {
          attachTouchListeners(row);
        }
      };

      const updateDynamicLayout = () => {
        const rows = getCurrentRows();
        const count = rows.length;
        const isNarrow = window.matchMedia("(max-width: 720px)").matches;
        const baseSizes = isNarrow
          ? { exercise: 14, note: 10, mini: 16 }
          : { exercise: 10.5, note: 8, mini: 12 };
        const scale = count > 6 ? Math.max(0.9, 1 - (count - 6) * 0.02) : 1;

        const setVar = (name, value) => {
          document.documentElement.style.setProperty(name, `${value.toFixed(2)}px`);
        };
        setVar("--exercise-font", baseSizes.exercise * scale);
        setVar("--note-font", baseSizes.note * scale);
        setVar("--mini-font", baseSizes.mini * scale);
        document.querySelectorAll(".exercise-note").forEach(autoResizeNote);

      };

      getCurrentRows().forEach((row) => {
        attachRowEventListeners(row);
        ensureRowHandle(row);
      });
      document.querySelectorAll(".exercise-note").forEach(autoResizeNote);
      updateDynamicLayout();

      window.addEventListener("resize", () => {
        updateDynamicLayout();
      });

      // Exercise context menu functionaliteit (nu met toegang tot Supabase functies)
      let attachTouchListeners = null;
      const setupExerciseContextMenu = () => {
        const exerciseModal = document.getElementById("exerciseModal");
        const addExerciseBtn = document.querySelector(".add-exercise");
        const deleteExerciseBtn = document.querySelector(".delete-exercise");
        let selectedRow = null;

        if (!exerciseModal || !addExerciseBtn || !deleteExerciseBtn) return;

        const openModal = (row) => {
          selectedRow = row;
          exerciseModal.classList.add("is-open");
          exerciseModal.setAttribute("aria-hidden", "false");
        };

        const closeModal = () => {
          exerciseModal.classList.remove("is-open");
          exerciseModal.setAttribute("aria-hidden", "true");
          selectedRow = null;
        };

        exerciseModal.addEventListener("click", (event) => {
          if (event.target === exerciseModal) closeModal();
        });
        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape" && exerciseModal.classList.contains("is-open")) {
            closeModal();
          }
        });

        // Touch long press detection
        let touchTimer = null;
        let touchStartPoint = null;
        let longPressTriggered = false;
        let suppressRowTapUntil = 0;
        const LONG_PRESS_DURATION = 500;
        const LONG_PRESS_MOVE_TOLERANCE = 10;

        const clearTouchTimer = () => {
          if (!touchTimer) return;
          clearTimeout(touchTimer);
          touchTimer = null;
        };

        const clearNativeSelection = () => {
          const active = document.activeElement;
          if (active && (active.tagName === "INPUT" || active.tagName === "TEXTAREA")) {
            active.blur();
          }
          const selection = window.getSelection && window.getSelection();
          if (selection && selection.rangeCount) {
            selection.removeAllRanges();
          }
        };

        const handleTouchStart = (e, row) => {
          if (e.target && e.target.closest && e.target.closest(".drag-handle")) return;
          longPressTriggered = false;
          touchStartPoint = {
            x: e.touches && e.touches[0] ? e.touches[0].clientX : 0,
            y: e.touches && e.touches[0] ? e.touches[0].clientY : 0,
          };
          clearTouchTimer();
          touchTimer = setTimeout(() => {
            longPressTriggered = true;
            suppressRowTapUntil = Date.now() + 700;
            clearNativeSelection();
            if (e.cancelable) e.preventDefault();
            openModal(row);
          }, LONG_PRESS_DURATION);
        };

        const handleTouchEnd = (e) => {
          clearTouchTimer();
          touchStartPoint = null;
          if (longPressTriggered && e && e.cancelable) {
            e.preventDefault();
          }
          longPressTriggered = false;
        };

        const handleTouchMove = (e) => {
          if (!touchTimer) return;
          if (!touchStartPoint || !e.touches || !e.touches[0]) {
            clearTouchTimer();
            return;
          }
          const dx = Math.abs(e.touches[0].clientX - touchStartPoint.x);
          const dy = Math.abs(e.touches[0].clientY - touchStartPoint.y);
          if (dx > LONG_PRESS_MOVE_TOLERANCE || dy > LONG_PRESS_MOVE_TOLERANCE) {
            clearTouchTimer();
          }
        };

        document.addEventListener(
          "click",
          (event) => {
            if (Date.now() > suppressRowTapUntil) return;
            const rowTarget = event.target && event.target.closest ? event.target.closest(".row") : null;
            if (!rowTarget) return;
            event.preventDefault();
            event.stopPropagation();
            clearNativeSelection();
          },
          true
        );

        // Functie om touch listeners toe te voegen aan een row
        attachTouchListeners = (row) => {
          row.addEventListener("touchstart", (e) => handleTouchStart(e, row), { passive: false });
          row.addEventListener("touchend", handleTouchEnd, { passive: false });
          row.addEventListener("touchmove", handleTouchMove, { passive: true });
          row.addEventListener("touchcancel", handleTouchEnd, { passive: false });
        };

        // Voeg touch event listeners toe aan alle rows
        const allRows = document.querySelectorAll(".row");
        allRows.forEach((row) => {
          attachTouchListeners(row);
        });

        // Functie om oefening te verwijderen
        deleteExerciseBtn.addEventListener("click", async () => {
          if (selectedRow) {
            console.log("Verwijderen oefening...");
            // Verwijder de row uit de DOM
            selectedRow.remove();
            closeModal();
            // Herindexeer en sla alle rows opnieuw op
            console.log("Herindexeren en opslaan...");
            await reindexAndSaveAllRows();
            console.log("Oefening verwijderd en opgeslagen");
          }
        });

        // Functie om nieuwe oefening toe te voegen
        addExerciseBtn.addEventListener("click", async () => {
          const grid = document.querySelector(".grid");
          if (!grid) return;

          // Bepaal het volgende nummer voor de nieuwe oefening
          const existingRows = getCurrentRows();
          const nextIndex = Math.max(1, existingRows.length);

          // Maak nieuwe row
          const newRow = buildRow(nextIndex);

          // Voeg toe boven de ingehouden (geselecteerde) row
          const inserted = insertRowBeforeSelected(newRow, selectedRow);
          if (!inserted) {
            insertRowBeforeLast(newRow);
          }

          // Initialiseer de nieuwe row
          initRow(newRow);

          // Herindexeer en sla alles op zodat indices blijven kloppen
          console.log("Herindexeren en opslaan...");
          await reindexAndSaveAllRows();
          console.log("Nieuwe oefening toegevoegd en opgeslagen");

          // Focus op het naam veld
          const nameInput = newRow.querySelector(".exercise-name");
          if (nameInput) {
            setTimeout(() => nameInput.focus(), 100);
          }

          closeModal();
        });
      };

      // Initialiseer exercise context menu
      setupExerciseContextMenu();

            const setupRowReorder = () => {
        const grid = document.querySelector(".grid");
        const sheet = document.querySelector(".sheet");
        if (!grid) return;

        let dragState = null;
        let rafId = null;
        let latestClientY = 0;

        const clearDropTargets = () => {
          grid.querySelectorAll(".row.reorder-drop-target").forEach((row) => row.classList.remove("reorder-drop-target"));
        };

        const cleanupFloatingStyles = (row) => {
          row.classList.remove("is-dragging-floating");
          row.style.left = "";
          row.style.top = "";
          row.style.width = "";
          row.style.height = "";
          row.style.margin = "";
        };

        const updateFloatingPosition = () => {
          rafId = null;
          if (!dragState) return;
          const deltaY = latestClientY - dragState.startClientY;
          dragState.row.style.top = `${dragState.startTop + deltaY}px`;
        };

        const scheduleFloatingPosition = (clientY) => {
          latestClientY = clientY;
          if (rafId !== null) return;
          rafId = requestAnimationFrame(updateFloatingPosition);
        };

        const maybeAutoScroll = (clientY) => {
          if (!sheet) return;
          const rect = sheet.getBoundingClientRect();
          const edge = 64;
          let delta = 0;
          if (clientY < rect.top + edge) {
            delta = -Math.max(4, (rect.top + edge - clientY) / 6);
          } else if (clientY > rect.bottom - edge) {
            delta = Math.max(4, (clientY - (rect.bottom - edge)) / 6);
          }
          if (delta !== 0) {
            sheet.scrollBy({ top: delta, behavior: "auto" });
          }
        };

        const movePlaceholder = (clientY) => {
          if (!dragState) return;
          const rows = getCurrentRows().filter((row) => row !== dragState.row && row !== dragState.placeholder);
          clearDropTargets();

          let inserted = false;
          for (const row of rows) {
            const rect = row.getBoundingClientRect();
            if (clientY < rect.top + rect.height / 2) {
              row.before(dragState.placeholder);
              row.classList.add("reorder-drop-target");
              inserted = true;
              break;
            }
          }

          if (!inserted) {
            if (rows.length) {
              rows[rows.length - 1].after(dragState.placeholder);
              rows[rows.length - 1].classList.add("reorder-drop-target");
            } else {
              const header = grid.querySelector(".header-row");
              if (header) {
                header.after(dragState.placeholder);
              } else {
                grid.appendChild(dragState.placeholder);
              }
            }
          }
        };

        const stopDrag = async (event) => {
          if (!dragState) return;
          if (event && event.pointerId !== dragState.pointerId) return;

          window.removeEventListener("pointermove", onPointerMove);
          window.removeEventListener("pointerup", stopDrag);
          window.removeEventListener("pointercancel", stopDrag);

          if (rafId !== null) {
            cancelAnimationFrame(rafId);
            rafId = null;
          }

          const { row, placeholder, pointerId, startIndex } = dragState;
          dragState = null;

          clearDropTargets();
          document.body.classList.remove("is-dragging-active");

          const activeHandle = row.querySelector(".drag-handle");
          if (activeHandle && activeHandle.hasPointerCapture(pointerId)) {
            activeHandle.releasePointerCapture(pointerId);
          }

          placeholder.replaceWith(row);
          cleanupFloatingStyles(row);
          updateDynamicLayout();

          const endIndex = getCurrentRows().indexOf(row);
          if (startIndex !== endIndex) {
            await reindexAndSaveAllRows();
          }
        };

        const onPointerMove = (event) => {
          if (!dragState || event.pointerId !== dragState.pointerId) return;
          if (event.cancelable) event.preventDefault();
          scheduleFloatingPosition(event.clientY);
          movePlaceholder(event.clientY);
          maybeAutoScroll(event.clientY);
        };

        grid.addEventListener("pointerdown", (event) => {
          if (!hasDataLoaded) return;
          if (event.button !== undefined && event.button !== 0) return;
          const handle = event.target.closest(".drag-handle");
          if (!handle) return;
          const row = handle.closest(".row");
          if (!row) return;

          const rect = row.getBoundingClientRect();
          const placeholder = document.createElement("div");
          placeholder.className = "row reorder-placeholder";
          placeholder.style.height = `${rect.height}px`;

          row.after(placeholder);

          row.classList.add("is-dragging-floating");
          row.style.left = `${rect.left}px`;
          row.style.top = `${rect.top}px`;
          row.style.width = `${rect.width}px`;
          row.style.height = `${rect.height}px`;
          row.style.margin = "0";

          document.body.classList.add("is-dragging-active");

          dragState = {
            row,
            placeholder,
            pointerId: event.pointerId,
            startClientY: event.clientY,
            startTop: rect.top,
            startIndex: getCurrentRows().indexOf(row),
          };

          handle.setPointerCapture(event.pointerId);
          latestClientY = event.clientY;

          window.addEventListener("pointermove", onPointerMove, { passive: false });
          window.addEventListener("pointerup", stopDrag);
          window.addEventListener("pointercancel", stopDrag);

          if (event.cancelable) event.preventDefault();
        });
      };

      setupRowReorder();

      const loadDayData = async () => {
        const loadId = ++dayToken;
        const dayName = day;
        if (dayName === REST_DAY_NAME) {
          renderRestDay();
          hasDataLoaded = true;
          hideLoadingOverlay();
          return;
        }
        clearRestDay();
        hasDataLoaded = false;
        resetRowsForLoad();
        console.log("Loading data for day:", dayName);
        let { data, error } = await supabase
          .from("workout_entries")
          .select("*")
          .eq("day", dayName)
          .order("exercise_index");
        if (loadId !== dayToken) return;
        if (error) {
          console.error("Supabase load failed:", error);
          applyDefaultsForAllRows();
          hasDataLoaded = true;
          hideLoadingOverlay();
          return;
        }
        const hashDay = getHashDay();
        const isTodayView = hashDay === "vandaag" || window.location.pathname.includes("vandaag");
        if (isTodayView && (!data || data.length === 0)) {
          const legacyKeys = ["Vandaag", "vandaag"];
          const { data: legacyData, error: legacyError } = await supabase
            .from("workout_entries")
            .select("*")
            .in("day", legacyKeys)
            .order("exercise_index");
          if (!legacyError && legacyData && legacyData.length) {
            const migrated = legacyData.map((item, index) => ({
              ...item,
              day: dayName,
              exercise_index: Number(item.exercise_index) || index + 1,
            }));
            const { error: migrateError } = await supabase
              .from("workout_entries")
              .upsert(migrated, { onConflict: "day,exercise_index" });
            if (!migrateError) {
              await supabase.from("workout_entries").delete().in("day", legacyKeys);
              data = migrated;
            } else {
              console.error("Fout bij migreren Vandaag-data:", migrateError);
            }
          }
        }
        console.log("Loaded data:", data);

        let resolvedData = Array.isArray(data) ? data : [];
        let usedCache = false;
        if (resolvedData.length === 0) {
          const cached = getCachedWorkoutData(dayName);
          if (cached && cached.length) {
            resolvedData = cached.map((item, idx) => normalizeEntry(item, idx, dayName));
            usedCache = true;
          } else if (templateRows.length) {
            resolvedData = templateRows.map((item, idx) => normalizeEntry(item, idx, dayName));
          }
        } else {
          setCachedWorkoutData(dayName, resolvedData);
        }

        if (usedCache) {
          supabase
            .from("workout_entries")
            .upsert(resolvedData, { onConflict: "day,exercise_index" })
            .then(({ error: restoreError }) => {
              if (restoreError) {
                console.error("Fout bij herstellen vanuit cache:", restoreError);
              }
            });
        }

        const isAllEmpty =
          resolvedData.length > 0 &&
          resolvedData.every((item) => {
            const name = (item.exercise_name || "").trim();
            const note = (item.note || "").trim();
            return (
              !name &&
              !note &&
              (item.sets == null || item.sets === "") &&
              (item.reps == null || item.reps === "") &&
              (item.weight == null || item.weight === "")
            );
          });
        if (isAllEmpty && templateRows.length) {
          resolvedData = templateRows.map((item, idx) => normalizeEntry(item, idx, dayName));
        }

        const maxIndex = resolvedData.reduce((max, item) => {
          const value = Number(item.exercise_index) || 0;
          return Math.max(max, value);
        }, 0);
        const currentRows = getCurrentRows();
        if (maxIndex > currentRows.length) {
          for (let i = currentRows.length; i < maxIndex; i++) {
            const newRow = buildRow(i + 1);
            insertRowAtEnd(newRow);
            initRow(newRow);
          }
        }
        if (resolvedData.length && maxIndex < currentRows.length) {
          getCurrentRows().slice(maxIndex).forEach((row) => row.remove());
        }
        resolvedData.forEach((item) => {
          const row = getCurrentRows()[item.exercise_index - 1];
          if (!row) return;
          const nameInput = row.querySelector(".exercise-name");
          const noteInput = row.querySelector(".exercise-note");
          const setsInput = row.querySelector('input[name^="sets-"]');
          const repsInput = row.querySelector('input[name^="reps-"]');
          const weightInput = row.querySelector('input[name^="gewicht-"]');

          if (nameInput && item.exercise_name != null) nameInput.value = item.exercise_name;
          if (noteInput && item.note != null) {
            noteInput.value = item.note;
            autoResizeNote(noteInput);
          }
          if (setsInput && item.sets != null) setsInput.value = item.sets;
          if (repsInput && item.reps != null) repsInput.value = item.reps;
          if (weightInput && item.weight != null) weightInput.value = item.weight;
        });
        updateDynamicLayout();
        applyDefaultsForAllRows();
        hasDataLoaded = true;
        hideLoadingOverlay();
      };
      loadDayData();

    })();
  </script>




  <div class="session-check-button" id="sessionCheckButton" aria-label="Markeer sessie als afgerond"></div>

<script>
if ("serviceWorker" in navigator) {
  window.addEventListener("load", () => {
    const basePath = window.__appBasePath || "/";
    navigator.serviceWorker.register(`${basePath}sw.js`);
  });
}
</script>
</body>
</html>
